/************************************
*	MapType for Athletics			*
*	Author: steeffeen				*
*	Contact: schteffens@gmail.com	*
************************************/

#RequireContext CSmMapType

#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Anchor.Script.txt" as Anchor

#Const	Version		"0.1 (2013-02-21)"

#Const	SpawnTags	["Lobby", "SkiJump", "Hurdles", "Swimming", "Sprint", "SpeedSkating"]
#Const	PoleTags	["SkiJumpPort",
					"HurdlesPort", "HurdlesFinish",
					"SwimmingPort", "SwimmingFinish",
					"SprintPort", "SprintFinish",
					"SpeedSkatingPort", "SpeedSkatingCP"]

// Initializes anchors
Void InitAnchors() {
	foreach (Anchor in AnchorData) {
		if (!SpawnTags.exists(Anchor.Tag) && !PoleTags.exists(Anchor.Tag)) {
			Anchor.Tag = Anchor.DefaultTag;
		}
	}
}

// Check if the map is valid
Void UpdateValidability() {
	ValidationStatus = CSmMapType::ValidationStatus::NotValidable;
	InitAnchors();
	Anchor::UpdateAnchorCounts();
	
	// Check lobby
	if (!Anchor::HasExactlyOneAnchor("Lobby", 0, "You must place exactly one lobby!")) return;
	
	// Check ports and spawns
	foreach (SpawnTag in SpawnTags) {
		switch (SpawnTag) {
			case "Lobby": {
				
			}
			default: {
				// Check if spawn exists
				if (Anchor::HasAtLeastOneAnchor(SpawnTag, 0, "")) {
					// Error if port is missing or exists too often
					if (!Anchor::HasExactlyOneAnchor(SpawnTag^"Port", 0, """You must place exactly one {{{SpawnTag}}} port if you have a {{{SpawnTag}}} spawn!""")) return;
				}
				// Check if port exists once
				if (Anchor::HasAtLeastOneAnchor(SpawnTag^"Port", 0, "")) {
					// Error if spawn is missing
					if (!Anchor::HasAtLeastOneAnchor(SpawnTag, 0, """You must place at least one {{{SpawnTag}}} spawn if you have a {{{SpawnTag}}} port!""")) return;
				}
			}
		}
	}
	
	// Check finishes and CPs
	foreach (Anchor in AnchorData) {
		switch (Anchor.Tag) {
			// Hurdles
			case "Hurdles": {
				if (!Anchor::HasAtLeastOneAnchor("HurdlesFinish", 0, "You must place at least one hurdles finish if you have a hurdles spawn!")) return;
			}
			// Swimming
			case "Swimming": {
				if (!Anchor::HasAtLeastOneAnchor("SwimmingFinish", 0, "You must place at least one swimming finish if you have a swimming spawn!")) return;
			}
			// Sprint
			case "Sprint": {
				if (!Anchor::HasAtLeastOneAnchor("SprintFinish", 0, "You must place at least one sprint finish if you have a sprint spawn!")) return;
			}
			// Speed skating
			case "SpeedSkating": {
				if (!Anchor::HasAtLeastXAnchor("SpeedSkatingCP", 0, 2, "You must place at least two speed skating CPs if you have a speed skating spawn!")) return;
			}
		}
	}
	
	ValidabilityRequirementsMessage = "";
	ValidationStatus = CSmMapType::ValidationStatus::Validated;
}

// Return the manialink for spawn anchor edition
Text EditSpawnAnchorManialink(Ident _AnchorId) {
	declare Manialink = """
	<script><!--
		#Include "TextLib" as TextLib
		
		main() {
			declare Buttons = [""";
	for (Index, 0, SpawnTags.count-2) {
		Manialink ^= """
			(Page.GetFirstChild("{{{SpawnTags[Index]}}}") as CMlLabel),""";
	}
	Manialink ^= """
			(Page.GetFirstChild("{{{SpawnTags[SpawnTags.count-1]}}}") as CMlLabel)];
			
			declare Integer AnchorOrder for Page;
			declare Text AnchorTag for Page;
			declare Boolean Finish for Page;
			
			Finish = False;	
			while (!Finish) {
				yield;
				
				foreach (Button in Buttons) {
					if (AnchorTag == Button.ControlId) {
						Button.Value = "$090"^Button.ControlId;
					} else {
						Button.Value = "$fff"^Button.ControlId;
					}
				}
				
				foreach (Index => Event in PendingEvents) {
					switch (Event.Type){
						case CMlEvent::Type::MouseClick: {
							if (Event.ControlId != "Cancel") {
								AnchorTag = Event.ControlId;
								AnchorOrder = 0;
							}
							Finish = True;
						}	
					}
				}
			}
		}			
	--></script>
	<frame posn="120 45">
		<quad posn="0 0 2" sizen="74 15" halign="center" valign="bottom" style="Bgs1InRace" substyle="BgTitle3_5"/>
		<label posn="0 5 3" halign="center" valign="bottom" style="TextTitle3" text="$fffEdit Spawn" />
		
		<quad posn="0 0 -1" sizen="70 {{{SpawnTags.count*7+16}}}" halign="center" style="Bgs1" substyle="BgWindow2"/>
		<frame posn="0 -13">
			<label id="Lobby" posn="0 10" scale="1.8" halign="center" style="TextButtonMedium" ScriptEvents="true"/>""";
	for (Index, 1, SpawnTags.count-1) {
		Manialink ^= """
			<label id="{{{SpawnTags[Index]}}}" posn="0 {{{8-Index*7}}}" scale="1.7" halign="center" style="TextButtonMedium" ScriptEvents="true"/>""";
	}
	Manialink ^= """
			<label id="Cancel" text="Cancel" posn="0 {{{-(SpawnTags.count-1)*7}}}" halign="center" style="CardButtonSmall" ScriptEvents="true"/>
		</frame>
    </frame>""";
	return Manialink;
}

// Return the manialink for goal anchor edition
Text EditGoalAnchorManialink(Ident _AnchorId) {
	declare Manialink = """
	<script><!--
		#Include "TextLib" as TextLib
		
		main() {
			declare Buttons = [""";
	for (Index, 0, PoleTags.count-2) {
		Manialink ^= """
			(Page.GetFirstChild("{{{PoleTags[Index]}}}") as CMlLabel),""";
	}
	Manialink ^= """
			(Page.GetFirstChild("{{{PoleTags[PoleTags.count-1]}}}") as CMlLabel)];
			
			declare Integer AnchorOrder for Page;
			declare Text AnchorTag for Page;
			declare Boolean Finish for Page;
			
			Finish = False;	
			while (!Finish) {
				yield;
				
				foreach (Button in Buttons) {
					if (AnchorTag == Button.ControlId) {
						Button.Value = "$090"^Button.ControlId;
					} else {
						Button.Value = "$fff"^Button.ControlId;
					}
				}
				
				foreach (Index => Event in PendingEvents) {
					switch (Event.Type){
						case CMlEvent::Type::MouseClick: {
							if (Event.ControlId != "Cancel") {
								AnchorTag = Event.ControlId;
								AnchorOrder = 0;
							}
							Finish = True;
						}	
					}
				}
			}
		}			
	--></script>
	<frame posn="120 45">
		<quad posn="0 0 2" sizen="74 15" halign="center" valign="bottom" style="Bgs1InRace" substyle="BgTitle3_5"/>
		<label posn="0 5 3" halign="center" valign="bottom" style="TextTitle3" text="$fffEdit" />
		
		<quad posn="0 0 -1" sizen="70 {{{PoleTags.count*6+18}}}" halign="center" style="Bgs1" substyle="BgWindow2"/>
		<frame posn="0 -13">""";
	for (Index, 0, PoleTags.count-1) {
		Manialink ^= """
			<label id="{{{PoleTags[Index]}}}" posn="0 {{{8-Index*6}}}" scale="1.5" halign="center" style="TextButtonMedium" ScriptEvents="true"/>""";
	}
	Manialink ^= """
			
			<label id="Cancel" text="Cancel" posn="0 {{{-(PoleTags.count-1)*6}}}" halign="center" style="CardButtonSmall" ScriptEvents="true"/>
		</frame>
    </frame>""";
	return Manialink;
}

// Show the anchor edition manialink
Void EditAnchorData(Ident _EditedAnchorDataId) {
	declare Integer AnchorOrder for ManialinkPage;
	declare Text AnchorTag for ManialinkPage;
	declare Boolean Finish for ManialinkPage;
	
	AnchorOrder = AnchorData[_EditedAnchorDataId].Order;
	AnchorTag = AnchorData[_EditedAnchorDataId].Tag;
	switch (AnchorData[_EditedAnchorDataId].DefaultTag) {
		case "Spawn": {
			ManialinkText = EditSpawnAnchorManialink(_EditedAnchorDataId);
		}
		case "Goal": {
			ManialinkText = EditGoalAnchorManialink(_EditedAnchorDataId);
		}
	}
	
	Finish = False;
	while (!Finish) {
		yield;
	}
	
	AnchorData[_EditedAnchorDataId].Order = AnchorOrder;
	AnchorData[_EditedAnchorDataId].Tag = AnchorTag;
	
	UpdateValidability();
}

// Main
main() {
	CustomEditAnchorData = True;
	UpdateValidability();
	
	while (True) {
		yield;
		
		ManialinkText = "";
		foreach (Index => Event in PendingEvents) {
			switch (Event.Type) {
				case CPluginEvent::Type::MapModified: {
					UpdateValidability();
				}
				case CPluginEvent::Type::EditAnchor: {
					EditAnchorData(Event.EditedAnchorDataId);
				}
			}
		}		
	}	
}
