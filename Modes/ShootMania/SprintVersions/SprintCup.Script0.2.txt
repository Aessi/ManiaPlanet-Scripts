/****************************************
*	SprintCup Game Mode					*
*	Author: 	steeffeen				*
*	Contact:	schteffens@gmail.com	*
****************************************/

/* TODO:
- manialink: dynamic list of finished players with times (live ranking even for current checkpoint?)
- km/h anzeige
*/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"TimeAttackArena,SprintCupArena"
#Const	Version				"0.2 (2013-05-24)"
#Const	ScriptName			"SprintCup.Script.txt"

#Const	Description		_("$<$oObjective:$> Finish the races as fast as possible. The player who reaches the point limit first wins the Map.")

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Chrono.Script.txt" as Chrono
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/ShootMania/AFK.Script.txt" as AFK
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

// SETTINGS
#Setting	S_PointsLimit			125		as _("Points Limit")
#Setting	S_RaceFinishLimit		15		as _("Time limit to finish a race after first players (seconds)")
#Setting	S_WarmUpRounds			1		as _("Number of WarmUp rounds per map")
#Setting	S_EnablePvP				False	as _("Enable PvP Weapons")

// CONSTANTS
#Const		C_PointsList			[25, 18, 15, 12, 10, 8, 6, 4, 2, 1]	// Points granting for the specific ranks
#Const		C_ChronoPosition		<50., -78.>		// Position of the chrono
#Const		C_RankingsListLength	10				// Length of rankings list
#Const		C_RankingsListPosition	<-157., 47.>	// Position of rankings list and warmup label

// GLOBALES
declare Integer			G_RankListReset;	// Time when the rankings list needs to be cleared
declare Boolean			G_WarmUp;			// Whether it's currently warmup
declare Integer			G_MapRound;			// Number of the round on the current map
declare Integer			G_CheckpointsCount;	// Number of checkpoints on the current map
declare Ident[]			G_StartedPlayers;	// Ids of currently racing players
declare Integer[Ident]	G_FinishedPlayers;	// Times of finished players
declare Boolean			Old_EnablePvP;		// Cache for enable pvp
declare Integer			Old_PointsLimit;	// Cache for points limit

// EXTEND
***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(Chrono::GetScriptName(), Chrono::GetScriptVersion());
MB_LogVersion(Interface::GetScriptName(), Interface::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(ScoresTable::GetScriptName(), ScoresTable::GetScriptVersion());
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
***

***StartServer***
***
Users_SetNbFakeUsers(1,0);
// Set mode options
UsePvPCollisions = False;
UsePvPWeapons = S_EnablePvP;
UseClans = False;
MB_UseSectionRound = True;

Old_EnablePvP = S_EnablePvP;
Old_PointsLimit = S_PointsLimit;

// UI
SM::SetupDefaultVisibility();
SpawnScreen::CreateRules("SprintCup", _("You must finish the races as fast as possible.\nEach race grants points for the best players\nThe player who reaches the point limit first wins the map."));
SpawnScreen::CreateMapInfo();
Interface::CreateRank();
Chrono::Load();
Chrono::SetPosition(NullId, C_ChronoPosition[0], C_ChronoPosition[1]);

ScoresTable::Load();
ScoresTable::SetTableFormat(2, 6);
ScoresTable::SetTableBackgroundImage("file://Media/Manialinks/ShootMania/Common/topsBg.dds", <0.05, 56.>, <207., 178.>);
ScoresTable::SetColumnsWidth(2.5, 1.5, 2.5, 15., 1.7, 1.7, 0.5, 3.5, 0.5, 0., 4.);
ScoresTable::SetColumnName("Custom2", _("|Name for best value|Best"));
ScoresTable::SetColumnName("Points", _("Points"));
ScoresTable::SetDefaultCustom2("-:--.--");
ScoresTable::SetScoreFormat("$o");
ScoresTable::SetDefaultFooterScore(" ");
ScoresTable::SetDefaultFooterStats(TextLib::Compose(_(" Points limit: %1"), TextLib::ToText(S_PointsLimit)));
ScoresTable::Build();

declare MarkersLayer <=> UIManager.UILayerCreate();
MarkersLayer.Type = CUILayer::EUILayerType::Markers;
UIManager.UIAll.UILayers.add(MarkersLayer);

declare ExtrasLayer <=> UIManager.UILayerCreate();
ExtrasLayer.ManialinkPage = GetExtrasLayerManialink();
UIManager.UIAll.UILayers.add(ExtrasLayer);

declare RankingsLayer <=> UIManager.UILayerCreate();
RankingsLayer.ManialinkPage = GetRankingsLayerManialink();
UIManager.UIAll.UILayers.add(RankingsLayer);
***

***StartMap***
***
// New map message
Message::CleanAllMessages();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

// Prepare map
foreach (Base in Bases) {
	Base.Clan = 0;
	Base.IsActive = True;
}
G_CheckpointsCount = 0;
foreach (Pole in BlockPoles) {
	Pole.Gauge.ValueReal = 1.0;
	Pole.Captured = True;
	switch (Pole.Tag) {
		case "Checkpoint": {
			G_CheckpointsCount += 1;
		}	
	}
}
{
	declare netwrite Integer Net_G_CheckpointsCount for Teams[0];
	Net_G_CheckpointsCount = G_CheckpointsCount;
}

foreach (Player in AllPlayers) {
	InitPlayer(Player, True);
}

Score::MatchBegin();
Score::RoundBegin();
ScoresTable::StartMatch();
foreach (Player in AllPlayers) {
	ScoresTable::SetCustom2(Player, "");
}
G_WarmUp = True;
G_MapRound = 0;

ExtrasLayer.IsVisible = True;
UIManager.UIAll.Hud3dMarkers = GetHud3dMarkers();
MarkersLayer.ManialinkPage = GetMarkersManialink();
MarkersLayer.IsVisible = True;
RankingsLayer.IsVisible = True;
Interface::AttachRank();
***

***StartRound***
***
G_StartedPlayers.clear();
G_FinishedPlayers.clear();

G_MapRound += 1;
G_WarmUp = (G_MapRound <= S_WarmUpRounds && S_WarmUpRounds > 0);
{
	declare netwrite Text Net_RemainingWarmUp for Teams[0];
	if (G_WarmUp) {
		Net_RemainingWarmUp = G_MapRound^"/"^S_WarmUpRounds;
	} else {
		Net_RemainingWarmUp = "";
	}
}
Message::CleanBigMessages();
if (G_MapRound == S_WarmUpRounds+1 || (S_WarmUpRounds < 0 && G_MapRound == 1)) {
	Message::SendBigMessage(_("Match Start!"), 2000, 2, CUIConfig::EUISound::StartRound, 0);
}

G_RankListReset = Now + 2500;
UIManager.UIAll.OverlayHideCountdown = True;
StartTime = Now + 3000;
EndTime = -1;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
***

***OnNewPlayer***
***
InitPlayer(Player, False);
Chrono::Create(Player.Id);
Chrono::SetPosition(Player.Id, C_ChronoPosition[0], C_ChronoPosition[1]);
ScoresTable::RestoreCustomScores(Player);
***

***OnNewSpectator***
***
InitPlayer(Spectator, False);
Chrono::Create(Spectator.Id);
Chrono::SetPosition(Spectator.Id, C_ChronoPosition[0], C_ChronoPosition[1]);
ScoresTable::RestoreCustomScores(Spectator);
***

***PlayLoop***
***
if (G_RankListReset > 0 && Now >= G_RankListReset) {
	G_RankListReset = -1;
	foreach (Player in AllPlayers) {
		declare netwrite Integer Net_CurrentTime for Player;
		Net_CurrentTime = -1;
	}
}
CheckScriptSettings();
AFK::ManageAFKPlayers();
Message::Loop();
UpdateExtrasLayer();

// Update settings
if (Old_PointsLimit != S_PointsLimit) {
	Old_PointsLimit = S_PointsLimit;
	declare Message = TextLib::Compose(_(" Points limit: %1"), TextLib::ToText(S_PointsLimit));
	foreach (Player in AllPlayers) {
		ScoresTable::SetFooterStats(Player, Message);
	}
}

// Manage events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnArmorEmpty: {
			RestartPlayer(Event.Victim, True, Now+3000);
			Discard(Event);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			RestartPlayer(Event.Player, True, Now+3000);
			Discard(Event);
		}
		case CSmModeEvent::EType::OnHit: {
			Discard(Event);
		}
		default: {
			PassOn(Event);
		}
	}
}

// Manage players
foreach (Player in Players) {			
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			if (G_StartedPlayers.exists(Player.Id)) continue;
			if (G_FinishedPlayers.existskey(Player.Id)) continue;
			RestartPlayer(Player, False, StartTime);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			if (Player.BlockPole == Null) continue;
			declare CheckpointsTimes for Player = Integer[Ident];
			switch (Player.BlockPole.Tag) {
				case "Checkpoint": {
					ActivateCheckpoint(Player, Player.BlockPole.Id);
				}
				case "Goal": {
					ActivateFinish(Player);
				}
			}
		}
	}
}

// Round end conditions
if (EndTime > 0 && Now >= EndTime + 400 ||
	G_StartedPlayers.count > 0 && (PlayersNbAlive == 0 || G_FinishedPlayers.count >= G_StartedPlayers.count)) {
	MB_StopRound = True;
}
***

***EndRound***
***
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
// Determine and announce round winner
declare RaceWinnerId = NullId;
declare RaceWinTime = -1;
foreach (PlayerId => RunTime in G_FinishedPlayers) {
	if (RaceWinnerId == NullId || RunTime < RaceWinTime) {
		RaceWinnerId = PlayerId;
		RaceWinTime = RunTime;
	}
}
if (!G_WarmUp && Players.existskey(RaceWinnerId)) {
	Message::SendBigMessage(TextLib::Compose(_("$<%1$> wins the Round!"), Players[RaceWinnerId].Name), 3000, 1);
}
MB_Sleep(1500);
UIManager.UIAll.OverlayHideCountdown = True;
EndTime = -1;
StartTime = -1;
// Match end conditions
foreach (Score in Scores) {
	if (Score.Points >= S_PointsLimit) {
		MB_StopMap = True;
	}
}
if (!MB_StopMap) {
	SM::UnspawnAllPlayers();
}
MB_Sleep(2500);
***

***EndMap***
***
foreach (Player in Players) {
	Chrono::Reset(Player.Id);
}

Score::RoundEnd();
Score::MatchEnd();
ScoresTable::EndMatch();

ExtrasLayer.IsVisible = False;
MarkersLayer.IsVisible = False;
RankingsLayer.IsVisible = False;
Interface::DetachRank();

// Determine and announce winner
declare CSmScore Winner <=> Null;
foreach (Score in Scores) {
	declare BestRunTime as BestRunTimeWinner for Winner = -1;
	declare BestRunTime as BestRunTimeThis for Score = -1;
	if (Score.Points > 0 && (Winner == Null || Score.Points > Winner.Points ||
		(Score.Points == Winner.Points && BestRunTimeThis < BestRunTimeWinner))) {
		Winner <=> Score;
	}
}

declare Message = _("|Match|Draw");
if (Winner != Null && Winner.User != Null) {
	Message = TextLib::Compose(_("$<%1$> wins the Match!"), Winner.User.Name);
}
Message::SendBigMessage(Message, 5000, 2);
MB_Sleep(3000);

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(5000);
***

***EndServer***
***
ScoresTable::Unload();
Interface::DestroyRank();
Chrono::Unload();
SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();
UIManager.UILayerDestroyAll();
***

// FUNCTIONS

// Check for changes of script settings
Void CheckScriptSettings() {
	// Check enable pvp
	if (UsePvPWeapons != S_EnablePvP) {
		UsePvPWeapons = S_EnablePvP;
		Old_EnablePvP = S_EnablePvP;
		declare Color = "$0f0";
		declare Status = "";
		if (!UsePvPWeapons) {
			Color = "$f00";
			Status = "de";
		}
		UIManager.UIAll.SendChat("Info>>$<$f80PvP Weapons$> are now $<"^Color^Status^"activated$>!");
	}
}

// Determine CPSpawn for checkpoint respawns
Ident GetCPSpawnId(CSmPlayer _Player) {
	if (_Player == Null) return NullId;
	declare LastCheckPointId for _Player = NullId;
	if (!BlockPoles.existskey(LastCheckPointId)) return NullId;
	declare SpawnId = NullId;
	declare CPPole <=> BlockPoles[LastCheckPointId];
	if (CPPole.Order != 0) {
		// Find assigned CPSpawn
		foreach (Spawn in BlockSpawns) {
			switch (Spawn.Tag) {
				case "CPSpawn": {
					if (Spawn.Order == CPPole.Order) {
						return Spawn.Id;
					}
				}
			}
		}
	}
	// No specific CPSpawn assigned, determine closest one
	declare Distance = -1.;
	foreach (Spawn in BlockSpawns) {
		switch (Spawn.Tag) {
			case "CPSpawn": {
				if (Spawn.Order > CPPole.Order) continue;
				declare SpawnDistance = MathLib::Distance(Spawn.Position, CPPole.Position);
				if (SpawnDistance < Distance || Distance < 0) {
					SpawnId = Spawn.Id;
					Distance = SpawnDistance;
				}
			}
		}
	}
	return SpawnId;
}

// Initialize the player
Void InitPlayer(CSmPlayer _Player, Boolean _Full) {
	if (_Player == Null) return;
	
	declare Ident LastCheckPointId for _Player;
	declare Integer[Ident] CheckpointsTimes for _Player;
	LastCheckPointId = NullId;
	CheckpointsTimes.clear();
	
	declare Temp = G_StartedPlayers.remove(_Player.Id);
	Temp = G_FinishedPlayers.removekey(_Player.Id);
	
	if (!_Full || _Player.Score == Null) return;
	
	declare Integer BestRunTime for _Player.Score;
	BestRunTime = -1;
}

// Update footer score for given player
Void UpdateFooterScore(CSmPlayer _Player) {
	if (_Player == Null) return;
	
	if (G_FinishedPlayers.existskey(_Player.Id)) {
		ScoresTable::SetFooterScore(_Player, TextLib::Compose(_("Race Rank: %1/%2"),
			TextLib::ToText(G_FinishedPlayers.count), TextLib::ToText(G_StartedPlayers.count)));
	} else {
		declare CheckpointsTimes for _Player = Integer[Ident];
		ScoresTable::SetFooterScore(_Player, TextLib::Compose(_("|Progress on checkpoints|Progress: CP %1/%2"),
			TextLib::ToText(CheckpointsTimes.count), TextLib::ToText(G_CheckpointsCount)));
	}
}

// Restart a player
Void RestartPlayer(CSmPlayer _Player, Boolean _UseCPSpawns, Integer _StartTime) {
	if (_Player == Null) return;
	if (_Player.RequestsSpectate) return;
	
	if (_UseCPSpawns) {
		declare CPSpawnId = GetCPSpawnId(_Player);
		if (BlockSpawns.existskey(CPSpawnId)) {
			SM::SpawnPlayer(_Player, 0, BlockSpawns[CPSpawnId], _StartTime);
			return;
		}
	}
	
	declare Ident LastCheckPointId for _Player;
	declare Integer[Ident] CheckpointsTimes for _Player;
	LastCheckPointId = NullId;
	CheckpointsTimes.clear();
	
	declare netwrite Integer Net_CheckpointsCount for _Player;
	Net_CheckpointsCount = CheckpointsTimes.count;
	
	Chrono::Start(_Player.Id, StartTime-Now);
	if (!G_StartedPlayers.exists(_Player.Id)) {
		G_StartedPlayers.add(_Player.Id);
	}
	UpdateFooterScore(_Player);
	
	SM::SpawnPlayer(_Player, 0, SM::GetSpawn("Spawn", 0), _StartTime);
}

// A player reaches a checkpoint
Void ActivateCheckpoint(CSmPlayer _Player, Ident _CheckpointId) {
	if (_Player == Null) return;
	if (!BlockPoles.existskey(_CheckpointId)) return;
	
	declare CheckpointsTimes for _Player = Integer[Ident];
	if (CheckpointsTimes.existskey(_CheckpointId)) return;
	if (BlockPoles[_CheckpointId].Order != 0 && BlockPoles[_CheckpointId].Order != CheckpointsTimes.count+1) {
		declare LastStatusMessage for _Player = 0;
		if (LastStatusMessage + 3000 < Now) {
			LastStatusMessage = Now;
			Message::SendStatusMessage(_Player, _("Wrong Checkpoint!"), 3000, 1);
		}
		return;
	}
	
	declare Ident LastCheckPointId for _Player;
	LastCheckPointId = _CheckpointId;
	CheckpointsTimes[_CheckpointId] = Now;
	
	declare netwrite Integer Net_CheckpointsCount for _Player;
	Net_CheckpointsCount = CheckpointsTimes.count;
	UpdateFooterScore(_Player);
	
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		UI.SendNotice(TextLib::Compose(_("Checkpoint %1/%2: %3"),
			TextLib::ToText(CheckpointsTimes.count), TextLib::ToText(G_CheckpointsCount),
			TextLib::TimeToText(Now - StartTime, True)),
			CUIConfig::ENoticeLevel::MapInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Checkpoint, CheckpointsTimes.count);
	}
}

// Calculate race points depending on finished players
Integer GetFinishPoints(Integer _Rank) {
	if (G_WarmUp || !C_PointsList.existskey(_Rank-1)) return 0;
	return C_PointsList[_Rank-1];
}

// A player reaches the goal
Void ActivateFinish(CSmPlayer _Player) {
	if (_Player == Null) return;
	if (G_FinishedPlayers.existskey(_Player.Id)) return;
	
	declare CheckpointsTimes for _Player = Integer[Ident];
	if (CheckpointsTimes.count < G_CheckpointsCount) {
		declare LastStatusMessage for _Player = 0;
		if (LastStatusMessage + 3000 < Now) {
			LastStatusMessage = Now;
			declare Extra = "";
			if (G_CheckpointsCount-CheckpointsTimes.count > 1) {
				Extra = "s";
			}
			Message::SendStatusMessage(_Player, TextLib::Compose(_("%1You missed %2 Checkpoint%3!"),
				"$f00", TextLib::ToText(G_CheckpointsCount-CheckpointsTimes.count), Extra), 3000, 1);
		}
		return;
	}
	
	declare netwrite Integer Net_CheckpointsCount for _Player;
	Net_CheckpointsCount = 0;
	
	declare RunTime = Now - StartTime;
	Chrono::Stop(_Player.Id);
	
	if (_Player.Score != Null && !G_WarmUp) {
		_Player.Score.Points += GetFinishPoints(G_FinishedPlayers.count+1);
		declare BestRunTime for _Player.Score = -1;
		if (RunTime < BestRunTime || BestRunTime < 0) {
			BestRunTime = RunTime;
			ScoresTable::SetCustom2(_Player, TextLib::TimeToText(RunTime, True));
		}
	}
	
	G_FinishedPlayers[_Player.Id] = RunTime;
	if (G_FinishedPlayers.count == 1) {
		foreach (PlayerId in G_StartedPlayers) {
			if (G_FinishedPlayers.existskey(PlayerId) || !Players.existskey(PlayerId)) continue;
			Message::SendStatusMessage(Players[PlayerId], _("Hurry!"), 4000, 0);
		}
	}
	
	declare netwrite Integer Net_CurrentTime for _Player;
	Net_CurrentTime = RunTime;
	UpdateFooterScore(_Player);

	if (MB_UseScriptCallbacks) {
		XmlRpc.SendCallback("Finished", """{"Login":"{{{_Player.Login}}}", "Score":{{{RunTime}}}}""");
	}
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		UI.SendNotice(TextLib::Compose(_("Finish: %1"), TextLib::TimeToText(RunTime, True)),
			CUIConfig::ENoticeLevel::MatchInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Finish, 0);
	}
	
	if (EndTime < 0) {
		EndTime = Now + S_RaceFinishLimit * 1000;
		UIManager.UIAll.OverlayHideCountdown = False;
	}
	
	UnspawnPlayer(_Player);
}

// Create hud3dmarkers
Text GetHud3dMarkers() {
	declare Markers = "";
	foreach (Pole in BlockPoles) {
		Markers ^= """<marker pos="{{{Pole.Position[0]}}} {{{Pole.Position[1]}}} {{{Pole.Position[2]}}}" box="0 4 0"
			manialinkframeid="Frame_Pole{{{Pole.Id}}}" visibility="WhenInFrustum"/>""";
	}
	return Markers;
}

// Create manialink for markers layer
Text GetMarkersManialink() {
	declare Manialink = """<script><!--
	#Include "TextLib" as TextLib
	
	declare CMlFrame[] G_Frame_Poles;
	
	Void ShowMarkerForPole(Ident _PoleId, Boolean _Goal) {
		declare Frame_Pole <=> (Page.GetFirstChild("Frame_Pole"^_PoleId) as CMlFrame);
		Frame_Pole.Visible = True;
		foreach (Control in Frame_Pole.Controls) {
			Control.Visible = True;
		}
		declare Label_NextCP <=> (Frame_Pole.GetFirstChild("Label_NextCP") as CMlLabel);
		if (_Goal) {
			Label_NextCP.Value = _("Finish");
		} else {
			Label_NextCP.Value = TextLib::Compose(_("|Checkpoint No.|CP %1"),
				TextLib::ToText(BlockPoles[_PoleId].Order));
		}
		G_Frame_Poles.add(Frame_Pole);
	}
	
	Void HideFrames(CMlFrame[] _Frames) {
		foreach (Frame in _Frames) {
			Frame.Visible = False;
			foreach (Control in Frame.Controls) {
				Control.Visible = False;
			}
		}
	}
	
	main() {
		declare netread Net_G_CheckpointsCount for Teams[0] = -1;
		declare Old_CheckpointsCount = -2;
		
		while (True) {
			yield;
			
			if (InputPlayer == Null) continue;
			
			declare LocalPlayer <=> InputPlayer;
			if (IsSpectatorMode && GUIPlayer == Null) {
				HideFrames(G_Frame_Poles);
				G_Frame_Poles.clear();
				continue;
			}
			if (GUIPlayer != Null) LocalPlayer <=> GUIPlayer;
			
			declare netread Net_CheckpointsCount for LocalPlayer = -1;
			if (Old_CheckpointsCount == Net_CheckpointsCount) continue;
			Old_CheckpointsCount = Net_CheckpointsCount;
			
			HideFrames(G_Frame_Poles);
			G_Frame_Poles.clear();
			
			if (Net_CheckpointsCount == Net_G_CheckpointsCount) {
				foreach (Pole in BlockPoles) {
					switch (Pole.Tag) {
						case "Goal": {
							ShowMarkerForPole(Pole.Id, True);
						}
					}
				}
			} else {
				foreach (Pole in BlockPoles) {
					if (Pole.Order == Net_CheckpointsCount+1) {
						ShowMarkerForPole(Pole.Id, False);
						break;
					}
				}
			}
		}
	}
	--></script>
	<framemodel id="FrameModel_Pole">
		<label id="Label_NextCP" halign="center" valign="center2"/>
	</framemodel>""";
	foreach (Pole in BlockPoles) {
		Manialink ^= """<frameinstance modelid="FrameModel_Pole" id="Frame_Pole{{{Pole.Id}}}" hidden="1"/>""";
	}
	return Manialink;
}

// Create manialink for extras layer
Text GetExtrasLayerManialink() {
	declare WarmUpFlagWidth = 0.5;
	return """<script><!--
		#Include "TextLib" as TextLib
		
		main() {
			declare Frame_WarmUp <=> (Page.GetFirstChild("Frame_WarmUp") as CMlFrame);
			declare Label_WarmUp <=> (Page.GetFirstChild("Label_WarmUp") as CMlLabel);
			
			declare netread Net_RemainingWarmUp for Teams[0] = "";
			
			declare LastUIUpdate = 0;
			
			while (True) {
				yield;
				
				if (InputPlayer == Null) continue;
				
				foreach (Event in PendingEvents) {
					switch (Event.Type) {
						case CMlEvent::Type::KeyPress: {
							switch (Event.KeyCode) {
								case 29: {
									// Delete
									if (IsSpectatorMode || InputPlayer.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)
										continue;
									declare netwrite Integer Net_RetireTime for UI;
									Net_RetireTime = ArenaNow;
								}
							}
						}
					}
				}
				
				if (LastUIUpdate + 300 > Now) continue;
				LastUIUpdate = Now;
				
				if (Net_RemainingWarmUp != "") {
					Frame_WarmUp.Visible = True;
					Label_WarmUp.Value = TextLib::Compose(_("WarmUp: %1"), Net_RemainingWarmUp);
				} else {
					Frame_WarmUp.Visible = False;
				}
			}
		}
		--></script>
		<frame id="Frame_WarmUp" posn="{{{C_RankingsListPosition[0]+7.}}} {{{C_RankingsListPosition[1]+7.}}}" hidden="1">
			<label id="Label_WarmUp" posn="1 0" textsize="2" textprefix="$o$fc0" halign="left" valign="center2"/>
			<quad posn="0 0" sizen="{{{WarmUpFlagWidth*16.}}} {{{WarmUpFlagWidth*9.}}}"
				style="BgRaceScore2" substyle="Warmup" halign="right" valign="center2"/>
		</frame>""";
}

// Checks net variables of extras layer
Void UpdateExtrasLayer() {
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare netread Net_RetireTime for UI = 0;
		declare LastRetireTime for UI = 0;
		if (LastRetireTime < Net_RetireTime && Net_RetireTime > StartTime) {
			LastRetireTime = Net_RetireTime;
			UnspawnPlayer(Player);
		}
	}
}

// Create manialink for rankings layer
Text GetRankingsLayerManialink() {
	if (C_RankingsListLength <= 0) return "";
	declare Manialink = """<script><!--
		#Include "TextLib" as TextLib
		
		main() {
			declare Frame_Ranking <=> (Page.GetFirstChild("Frame_Ranking") as CMlFrame);
			declare Label_RankingHeader <=> (Frame_Ranking.GetFirstChild("Label_RankingHeader") as CMlLabel);
			
			declare RankingFrames = [""";
	for (Index, 1, C_RankingsListLength) {
		Manialink ^= Index^""" => (Frame_Ranking.GetFirstChild("Frame_Ranking{{{Index}}}") as CMlFrame)""";
		if (Index < C_RankingsListLength) {
			Manialink ^= ",";
		}
	}
	Manialink ^= """];
	
			foreach (Rank => Frame in RankingFrames) {
				declare Label_Rank <=> (Frame.GetFirstChild("Label_Rank") as CMlLabel);
				Label_Rank.Value = TextLib::ToText(Rank);
			}
			
			declare LastUIUpdate = 0;
			declare LastPlayerTimesCount = 0;
			
			while (True) {
				yield;
				
				if (InputPlayer == Null) continue;
				
				if (LastUIUpdate + 300 > Now) continue;
				LastUIUpdate = Now;
				
				declare Integer[Text] PlayersTimes;
				
				foreach (Player in Players) {
					declare netread Net_CurrentTime for Player = -1;
					if (Net_CurrentTime > 0) {
						PlayersTimes[Player.Name] = Net_CurrentTime;
					}
				}
				if (LastPlayerTimesCount == PlayersTimes.count) continue;
				LastPlayerTimesCount = PlayersTimes.count;
				
				PlayersTimes = PlayersTimes.sort();
				
				declare Rank = 1;
				foreach (Name => Time in PlayersTimes) {
					declare Frame <=> RankingFrames[Rank];
					declare Label_Name <=> (Frame.GetFirstChild("Label_Name") as CMlLabel);
					declare Label_Time <=> (Frame.GetFirstChild("Label_Time") as CMlLabel);
					
					Frame.Visible = True;
					Label_Name.Value = Name;
					Label_Time.Value = TextLib::TimeToText(Time, True);
					
					Rank += 1;
				}
				for (Index, Rank, {{{C_RankingsListLength}}}) {
					RankingFrames[Index].Visible = False;
				}
			}
		}
		--></script>
		<framemodel id="FrameModel_RankingFrame">
			<format textsize="1"/>
			<label id="Label_Rank" posn="0 0" sizen="3 0" textprefix="$o" halign="center" valign="center2"/>
			<label id="Label_Name" posn="3 0" sizen="20 0" halign="left" valign="center2"/>
			<label id="Label_Time" posn="25 0" sizen="10 0" halign="left" valign="center2"/>
		</framemodel>
		<frame id="Frame_Ranking" posn="{{{C_RankingsListPosition[0]}}} {{{C_RankingsListPosition[1]}}} -1">
			<label id="Label_RankingHeader" halign="center" valign="center2"/>""";
	for (Index, 1, C_RankingsListLength) {
		Manialink ^= """<frameinstance modelid="FrameModel_RankingFrame" id="Frame_Ranking{{{Index}}}" hidden="1"
			posn="0 {{{(1-Index)*3.5}}}"/>""";
	}
	Manialink ^= """
		</frame>""";
	return Manialink;
}