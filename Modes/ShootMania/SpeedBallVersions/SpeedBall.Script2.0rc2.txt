/****************************************
*	SpeedBall Game Mode					*
*	Author:		steeffeen				*
*	Contact:	schteffens@gmail.com	*
****************************************/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	ScriptName			"SpeedBall.Script.txt"
#Const	Version				"2.0 (2013-07-24)"
#Const	CompatibleMapTypes	"SpeedBallArena,SpeedBallTitleArena"

/*	INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/Top2.Script.txt" as Top
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/AFK.Script.txt" as AFK
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/WarmUpSimple.Script.txt" as WarmUp
#Include "Libs/steeffeen/ShootMania/Bots.Script.txt" as Bots
#Include "Libs/steeffeen/TeamStats.Script.txt" as TeamStats

/*****************************************************
	SETTINGS
*****************************************************/

// Rounds
#Setting	S_TimeLimitNormal			180		as _("Duration Normal Phase (seconds)")
#Setting	S_TimeLimitReduction		120		as _("Duration Reduction Phase (seconds)")
#Setting	S_TimeLimitInstant			300		as _("Duration Instant Phase (seconds)")
#Setting	S_TimeLimitMarker			480		as _("Duration during which the Ball marker is visible (seconds)")
#Setting	S_RoundsToWin				5		as _("Rounds to win a map")
#Setting	S_RoundGapToWin				2		as _("Rounds gap to win a map")
#Setting	S_RoundsLimit				10		as _("Total rounds limit per map (First team reaching X wins)")
#Setting	S_BestOfXMatch				0		as _("Play best-of-X-maps match")
#Setting	S_UseWarmUp					False	as _("Start a warmup before each map")
// Teams
#Setting	S_UsePlayerClublinks		False	as _("Enable use of player clublinks (needs restart vote)")
#Setting	S_AutoTeamBalance			False	as _("Automatically balance teams before each map")
// Gameplay
#Setting	S_FriendlyFire				False	as _("Friendly fire (Damage team members)")
#Setting	S_Mode						0		as _("Gameplay Mode (0: Normal, 1: Laser, 2: Random Weapon)")

// Hidden
#Setting	S_DefaultCaptureTime		1600	as "<hidden>"		// Default (not-reduced) capture time
#Setting	S_ManageAFKPlayers			True	as "<hidden>"		// Forces afk players into spec
#Setting	S_WarmUpDuration			60		as "<hidden>"		// WarmUp duration
#Setting	S_BotPower					10.		as "<hidden>"		// Power of the bots
#Setting	S_NbBotsBlue				0		as "<hidden>"		// Number of bots of team blue
#Setting	S_NbBotsRed					0		as "<hidden>"		// Number of bots of team red

/*****************************************************
	COMMANDS
*****************************************************/

#Command	Cmd_MapPointsClan1		(Integer)	as _("Set current map points of team 1")
#Command	Cmd_MapPointsClan2		(Integer)	as _("Set current map points of team 2")
#Command	Cmd_MatchPointsClan1	(Integer)	as _("Set current match points of team 1")
#Command	Cmd_MatchPointsClan2	(Integer)	as _("Set current match points of team 2")

/*****************************************************
	CONSTANTS
*****************************************************/

// Gameplay
#Const	C_ExtendedAntiBlockTime			5500		// Duration during which players don't block each other after roundbegin
#Const	C_BallCarrierArmorReplenishGain	200			// Value for the armor regeneration of the ball carrier
#Const	C_DroppedBallResetTime			4500		// Time until a dropped ball will reset
#Const	C_PlayerHighlightValue			0.6			// How much the players get highlighted (ball carrier -> 1.0)
#Const	C_BotsCanHaveBall				True		// Disable to disallow bots to have the ball
#Const	C_DecrDamageOnBall				True		// Ball carrier can only be hit for 1 damage (even from laser)
// UI
#Const	C_DefaultNeutralEmblemUrl		"http://team-devota.com/steeffeen/images/emblem_speedball.dds"		// Default neutral emblem URL
#Const	C_MissMessageMaxDist			0.9			// Maximum distance for near miss messages
#Const	C_HitMessageMinDist				50.			// Minimum distance for hit missage
#Const	C_NbTeamHitMessage				5			// Times the team hit warning appears (0: deactivated, -1: endless)

#Const	Description			_("$<$oObjective:$> Two teams fight for control of a $<$0f0Ball$> in order to capture the opponents goal post.")

// Top ranking names
#Const	T_Damage			"Damage"
#Const	T_Captures			"Captures"
#Const	T_Passes			"Passes"
#Const	T_BallHitters		"BallHitters"
#Const	T_BackStabber		"BackStabber"
#Const	T_CaptureTotal		"CaptureTotal"

// Stats names
#Const	T_BallPoss			"BallPossession"
#Const	T_CaptureTries		"CaptureTries"
#Const	T_EnemyKills		"EnemyKills"
#Const	T_TeamKills			"TeamKills"

/*****************************************************
	GLOBALES
*****************************************************/

declare Integer[Integer]	G_ClanMapScores;		// Won maps of each clan
declare Integer		G_Phase;						// Current gameplay phase (0: normal, 1: reduction, 2: instant)
declare Ident		G_BallItemId;					// Id of ball item
declare CSmObject	G_BallObject;					// Created ball object
declare Integer		G_BallDropTime;					// Time when the ball was dropped
declare Integer		G_BallArmorRegTime;				// Last time of ball armor regeneration
declare Integer		G_LastBallResetSeconds;			// Seconds of the last reset countdown tick
declare Integer		G_LastUIUpdate;					// Time when the last UI refresh was performed
declare Ident		G_BallPoleId;					// Id of the ball pole
declare Ident[Integer][Integer]	G_ClanSpawnIDs;		// BlockSpawn IDs of each clan
declare Integer[Integer]		G_LastSpawnIndex;	// Last spawn index of each clan
declare Ident[Integer]			G_ClanPoleIDs;		// BlockPole IDs of each clan
declare Integer		G_LastAfkHandling;				// Time of last afk players handling

/*****************************************************
	EXTENDED LABELS
*****************************************************/

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(AFK::GetScriptName(), AFK::GetScriptVersion());
MB_LogVersion(Bots::GetScriptName(), Bots::GetScriptVersion());
MB_LogVersion(Interface::GetScriptName(), Interface::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(ScoresTable::GetScriptName(), ScoresTable::GetScriptVersion());
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
MB_LogVersion(Tabs::GetScriptName(), Tabs::GetScriptVersion());
MB_LogVersion(TeamStats::GetScriptName(), TeamStats::GetScriptVersion());
MB_LogVersion(Top::GetScriptName(), Top::GetScriptVersion());
MB_LogVersion(Victory::GetScriptName(), Victory::GetScriptVersion());
MB_LogVersion(WarmUp::GetScriptName(), WarmUp::GetScriptVersion());
***

***ModeStatusMessage***
***
if (Players.count > 0) {
	declare Message = TextLib::Compose("%1\n$<$o%2:$> %3", Description, _("Score"),
		"$<"^Teams[0].ColorizedName^"$> $<"^Teams[0].ColorText^ClanScores[0]^"$> : $<"
			^Teams[1].ColorText^ClanScores[1]^"$> $<"^Teams[1].ColorizedName^"$>");
	ModeStatusMessage = Message;
} else {
	ModeStatusMessage = Description;
}
***

***Rules***
***
declare BallText = """$<$6f1Ball$>""";
declare ModeRules = """
- Two teams fight for control of the {{{BallText}}} in order to capture the opponents pole.
- Grab the {{{BallText}}} and get it to the enemys goalpost to score (which takes $<$f80{{{S_DefaultCaptureTime / 1000.}}}$> seconds).
- Once you have the {{{BallText}}}, hit a player to $<$3afpass$> the {{{BallText}}}.
- If the {{{BallText}}} carrier dies, the {{{BallText}}} will drop at his position. It can be picked up by any player on any team for $<$f80{{{C_DroppedBallResetTime / 1000.}}}$> seconds before it resets.
""";
if (S_TimeLimitMarker > 0) {
	ModeRules ^= """- After $<$f80{{{S_TimeLimitMarker / 60.}}}$> minutes the ball marker disappears!
""";
}
ModeRules ^= """
- $<$o1. Normal Phase:$> Lasts $<$f80{{{S_TimeLimitNormal / 60.}}}$> minutes. Normal capture time.
- $<$o2. Reduction Phase:$> Lasts $<$f80{{{S_TimeLimitReduction / 60.}}}$> minutes. The capture time constantly decreases.
- $<$o3. Instant Phase:$> The last $<$f80{{{S_TimeLimitInstant / 60.}}}$> minutes are running! Captures are instant!
""";
if (S_FriendlyFire) {
	ModeRules ^= """
- $<$f80Friendly Fire$> is activated! Pay attention to not damage your team mates!""";
}
switch (S_Mode) {
	case 1: {
		ModeRules ^= """
- $<$f80Laser Mode$> is activated! Players spawn with lasers!""";
	}
	case 2: {
		ModeRules ^= """
- $<$f80Random Mode$> is activated! Players spawn with random weapons!""";
	}
}
SpawnScreen::CreateRules("SpeedBall", ModeRules);
***

***StartServer***
***
// Load objects
ItemList_Begin();
G_BallItemId = ItemList_Add("SpeedBall\\Ball2.Item.gbx");
ItemList_End();

// Teams
UseClans = True;
Bots::Load();
Bots::SetPower(S_BotPower);

// Clublink & Emblem
MB_UsePlayerClublinks = S_UsePlayerClublinks;
if (MB_NeutralEmblemUrl == "") MB_NeutralEmblemUrl = C_DefaultNeutralEmblemUrl;

// Init variables
MB_UseSectionRound = True;
StartTime = -1;
EndTime = -1;
UIManager.UIAll.CountdownEndTime = -1;
G_LastUIUpdate = 0;
G_LastAfkHandling = 0;

// UI
SM::SetupDefaultVisibility();
UIManager.UIAll.UISequence_CanSkipIntroMT = True;
SpawnScreen::CreateMapInfo();
Interface::CreateRank();
// Hide map warnings to suppress the "Pole captured by X" message
UIManager.UIAll.NoticesFilter_HideMapWarning = True;

// Layers
declare LayerTeams <=> UIManager.UILayerCreate();
Interface::SetLayerTeams(LayerTeams);
UIManager.UIAll.UILayers.add(LayerTeams);

declare LayerMarkers <=> UIManager.UILayerCreate();
LayerMarkers.Type = CUILayer::EUILayerType::Markers;
LayerMarkers.ManialinkPage = CreateMarkersLayer();
UIManager.UIAll.UILayers.add(LayerMarkers);

declare LayerExtra <=> UIManager.UILayerCreate();
LayerExtra.ManialinkPage = CreateLayerExtra();
UIManager.UIAll.UILayers.add(LayerExtra);

// Tabs
Tabs::Load();
declare TabsLayer <=> Tabs::CreateTabPaneLayer(["ScoresTab" => "Rankings", "TopTab" => "Buddies", "TeamStatsTab" => "Statistics"], 14, -2, False);
TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
UIManager.UIAll.UILayers.add(TabsLayer);

// ScoresTable
ScoresTable::Load();
ScoresTable::SetTableWidth(220.);
ScoresTable::SetTableFormat(2, 6);
ScoresTable::SetColumnsWidth(1.7, 1.2, 3., 16., 1.4, 1.4, 0.1, 2.5, 2.5, 2.5, 3.2);
ScoresTable::SetDisplayTeamScore(True);
ScoresTable::SetColumnName("Custom2", _("|Amount of damage inflicted|Dmg"));
ScoresTable::SetColumnName("Custom3", _("|Number of passes done|Passes"));
ScoresTable::SetColumnName("RoundPoints", _("|A round of the match|Round"));
ScoresTable::SetRoundScoreFormat("$s$0d0");
ScoresTable::SetDefaultFooterStats(TextLib::Compose(_("Rounds to win: %1 (Limit: %2)"), TextLib::ToText(S_RoundsToWin), TextLib::ToText(S_RoundsLimit)));
ScoresTable::Build();

{
// Tops
declare TopWidth = 72.6;
Top::Load();
Top::SetLayerType(CUILayer::EUILayerType::AltMenu);
Top::SetTopWidth(TopWidth);
declare Tops = [
					T_Damage		=> _("Top Damage"),
					T_BallHitters	=> _("Top BallHitters"),
					T_Passes		=> _("Top Passes"),
					T_Captures		=> _("Top Captures"),
					T_CaptureTotal	=> _("Top Capture% Sum"),
					T_BackStabber	=> _("Flop BackStabber")
				];
declare Count = 1;
declare Line = 0;
foreach (Key => Name in Tops) {
	Top::Create(Key, Name, 7 - Line, <-147.4 + Count * (TopWidth + 1.1), 42. - Line * 48.8>);
	Count += 1;
	if (Count == 4) {
		Count = 1;
		Line += 1;
	}
}

// Team Stats
TeamStats::Load("TeamStatsTab");
declare Stats =	[
					T_BallPoss		=> _("Ball Possession"),
					T_Damage		=> _("Damage"),
					T_Passes		=> _("Passes"),
					T_CaptureTries	=> _("Capturing Tries"),
					T_EnemyKills	=> _("Enemy Eliminations"),
					T_TeamKills		=> _("Friend Eliminations")
				];
Count = 0;
foreach (Key => Name in Stats) {
	TeamStats::Create(Key, Name, "-", 14 - 10. * Count);
	Count += 1;
}
TeamStats::BuildManialink();
}
***

***StartMatch***
***
G_ClanMapScores = [1 => 0, 2 => 0];
if (S_BestOfXMatch > 0) {
	// Run match
	UIManager.UIAll.SendNotice(_("New Match!"),
		CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::StartMatch, 0);
	UpdateClanScoresSummary(True);
	MB_PlayersPresentationSequence(2500);
	MB_Sleep(500);
}
***

***StartMap***
***
// Create objects
G_BallObject = ObjectCreate(G_BallItemId);
Bots::SetTargetOject(G_BallObject);

// UI
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	
// Layers
Interface::AttachRank();
LayerTeams.IsVisible = True;

// Auto team balance
if (S_AutoTeamBalance) {
	Mode::AutoTeamBalance();
	SM::UnspawnAllPlayers();
}

// Prepare match
Score::MatchBegin();
ScoresTable::StartMatch();
Victory::MatchBegin();
Top::ResetAll();
ResetMatchTops();
ResetStatistics();

ClanScores[1] = 0;
ClanScores[2] = 0;

// Prepare map
G_ClanSpawnIDs[1] = Ident[Integer];
G_ClanSpawnIDs[2] = Ident[Integer];
G_ClanPoleIDs.clear();
G_BallPoleId = NullId;
foreach (Base in Bases) {
	Base.IsActive = True;
	Base.Clan = 0;
}
foreach (Index => Spawn in BlockSpawns) {
	G_ClanSpawnIDs[Spawn.Order][G_ClanSpawnIDs[Spawn.Order].count] = Spawn.Id;
}
foreach (Index => Pole in BlockPoles) {
	switch (Pole.Order) {
		case 3: {
			// Ball spawn
			G_BallPoleId = Pole.Id;
			Pole.Gauge.ValueReal = 1.;
			declare netwrite Integer Net_BallPoleIndex for Teams[0];
			Net_BallPoleIndex = Index;
			Bots::SetAnchorPoint(Pole.Position);
		}
		default: {
			G_ClanPoleIDs[3 - Pole.Order] = Pole.Id;
			Pole.Gauge.Max = S_DefaultCaptureTime;
		}
	}
}
---Rules---

// Start match
UpdateNetVariables();
// WarmUp
if (S_UseWarmUp) {
	WarmUp::Initialize(S_WarmUpDuration);
	WarmUp::Start();
}
// Clublinks
if (S_UsePlayerClublinks) {
	Clublink::DefineTeamAuto();
}
if (S_BestOfXMatch <= 0) {
	UIManager.UIAll.SendNotice("",
		CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::StartMatch, 0);
}
***

***StartRound***
***
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.SpectatorForcedTarget = NullId;
Score::RoundBegin();
ResetRoundTops();
AssignSpawnPoleClans();
UIManager.UIAll.SendNotice("",
	CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
	CUIConfig::EUISound::StartRound, 0);
Victory::RoundBegin();
LayerMarkers.IsVisible = True;
LayerExtra.IsVisible = True;

// Initialize values
G_BallObject.SetPosition(BlockPoles[G_BallPoleId].Position);
G_Phase = 0;
G_BallArmorRegTime = 0;
UpdateBaseClans();

// Set round times
StartTime = Now + 4000;
EndTime = StartTime + (S_TimeLimitNormal + S_TimeLimitReduction + S_TimeLimitInstant) * 1000;
UIManager.UIAll.CountdownEndTime = StartTime + S_TimeLimitNormal * 1000;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UsePvPCollisions = False;

UpdateNetVariables();
---ModeStatusMessage---
Bots::SetNbBots(S_NbBotsBlue, S_NbBotsRed);
***

***OnNewPlayer***
***
ScoresTable::RestoreCustomScores(Player);
declare UI <=> UIManager.GetUI(Player);
if (UI == Null) continue;
Tabs::UseTabs(UI, "ScoresTab");
***

***OnNewSpectator***
***
ScoresTable::RestoreCustomScores(Spectator);
declare UI <=> UIManager.GetUI(Spectator);
if (UI == Null) continue;
Tabs::UseTabs(UI, "ScoresTab");
***

***PlayLoop***
***
// Check anti block
if (!UsePvPCollisions && StartTime + C_ExtendedAntiBlockTime < Now) {
	UsePvPCollisions = True;
}
// Handle afk players
if (S_ManageAFKPlayers && G_LastAfkHandling + 30000 < Now) {
	G_LastAfkHandling = Now;
	AFK::ManageAFKPlayers();
}
// Library updates #1
Message::Loop();
Tabs::XmlRpcLoop();
Bots::Loop();

// Check for changed settings
CheckSettings();

// Perform actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			MySpawnPlayer(Player);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			// Check for respawn requests
			if (Player.CurrentClan != Player.RequestedClan || Player.RequestsSpectate) {
				if (Player == G_BallObject.Player) {
					DropBall(Player.Position);
				}
				UnspawnPlayer(Player);
			} else {
				if (G_BallObject.Player == Player) {
					// Ball carrier!
					Player.EnergyLevel = 1.;
					Player.ArmorReplenishGain = C_BallCarrierArmorReplenishGain;
					Player.UseAlternateWeaponVisual = True;
				} else {
					// Usual player (without ball)
					Player.EnergyLevel = C_PlayerHighlightValue;
					Player.ArmorReplenishGain = 0;
					// Reduce armor to even values if the player has partly regenerated armor
					if (Player.Armor > 100 && Player.Armor < 200) {
						Player.Armor = 100;
					}
					// Disable alternate ball weapon visual
					Player.UseAlternateWeaponVisual = False;
				}
			}
		}
	}
}

// Handle pending events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Victim == Null) {
				Discard(Event);
			} else {
				if (Event.Victim == G_BallObject.Player) {
					// Ball carrier died -> Drop the ball
					DropBall(Event.Victim.Position);
				}
				if (Event.Shooter != Null) {
					if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
						UpdateStatTeamKills(Event.Shooter.CurrentClan - 1, 1);
					} else {
						UpdateStatEnemyKills(Event.Shooter.CurrentClan - 1, 1);
					}
				}
				if (Event.Victim != Null && !Event.Victim.IsFakePlayer && (Event.Shooter == Null || !Event.Shooter.IsFakePlayer)) {
					XmlRpc::OnArmorEmpty(Event);
				}
				PassOn(Event);
			}
		}
		case CSmModeEvent::EType::OnHit: {
			if (Event.Shooter == Null || Event.Victim == Null) {
				// Discard buggy event
				Discard(Event);
			} else if (Event.Shooter == Event.Victim) {
				// Discard self damage
				Discard(Event);
			} else if (Event.Shooter == G_BallObject.Player) {
				// Ball carrier hit someone -> Pass the ball
				PassBall(Event.Shooter, Event.Victim);
				SendHitMessage(Event, True);
				Discard(Event);
			} else if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
				if (S_FriendlyFire) {
					// Friendly fire hits
					declare Points = -1;
					if (Event.Victim == G_BallObject.Player) {
						Points *= 2;
						if (C_DecrDamageOnBall) {
							Event.Damage = 100;
						}
					}
					Event.ShooterPoints = Points;
					AddPoints(Event.Shooter, Points);
					UpdateBackStabs(Event.Shooter, -Points);
					SendHitMessage(Event, False);
					// Kill victim if he hasn't full armor
					if (Event.Victim.Armor < 200) {
						Event.Damage = Event.Victim.Armor;
					}
					// Show team hit warning
					if (C_NbTeamHitMessage != 0) {
						declare NbTeamHitMessage for Event.Shooter = 0;
						if (C_NbTeamHitMessage < 0 || NbTeamHitMessage < C_NbTeamHitMessage) {
							Message::SendStatusMessage(Event.Shooter, TextLib::Compose("$f80%1", _("Attention! You shot a team member!")), 2500, 0);
							NbTeamHitMessage += 1;
						}
					}
					PassOn(Event);
				} else {
					// Discard team hits
					Discard(Event);
				}
			} else {
				// Calculate points for the hit
				declare Points = 1;
				if (Event.Victim == G_BallObject.Player) {
					Points *= 2;
					if (C_DecrDamageOnBall) {
						Event.Damage = 100;
					}
					UpdateBallHits(Event.Shooter, 1);
				}
				Event.ShooterPoints = Points;
				AddPoints(Event.Shooter, Points);
				UpdateDamage(Event.Shooter, Event.Damage / 100);
				UpdateStatDamage(Event.Shooter.CurrentClan - 1, Event.Damage / 100);
				SendHitMessage(Event, False);
				// Kill victim if he hasn't full armor
				if (Event.Victim.Armor < 200) {
					Event.Damage = Event.Victim.Armor;
				}
				if (!Event.Shooter.IsFakePlayer) {
					XmlRpc::OnHit(Event);
				}
				PassOn(Event);
			}
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			if (Event.Player == G_BallObject.Player) {
				// Ball carrier requested respawn -> Drop the ball
				DropBall(Event.Player.Position);
			}
			MySpawnPlayer(Event.Player);
			if (!Event.Player.IsFakePlayer) {
				XmlRpc::OnPlayerRequestRespawn(Event);
			}
			Discard(Event);
		}
		case CSmModeEvent::EType::OnCapture: {
			if (G_BallObject.Player != Null && Event.BlockPole.Gauge.Clan == G_BallObject.Player.CurrentClan) {
				// Captured! - Announce winner etc.
				Victory::SetRoundWinnerIfNoWinner(Event.BlockPole.Gauge.Clan);
				UIManager.UIAll.SpectatorForcedTarget = Event.BlockPole.Id;
				UIManager.UIAll.BigMessage = "";
				// Reward ball carrier
				AddPoints(G_BallObject.Player, 5);
				UpdateCaptures(G_BallObject.Player, 1);
				if (!G_BallObject.Player.IsFakePlayer) {
					XmlRpc.SendCallback("poleCapture", G_BallObject.Player.Login);
				}
				UIManager.UIAll.SendNotice(TextLib::Compose(_("$<%1$> scores for $<%2$>!"), G_BallObject.Player.Name,
					Teams[G_BallObject.Player.CurrentClan-1].ColorizedName),
					CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
					CUIConfig::EUISound::Capture, 0);
				PassOn(Event);
			} else {
				Discard(Event);
			}
		}
		case CSmModeEvent::EType::OnShoot: {
			// Near miss
			if (!Event.Shooter.IsFakePlayer) {
				XmlRpc::OnShoot(Event);
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnNearMiss: {
			// Near miss
			if (Event.Shooter != Null && !Event.Shooter.IsFakePlayer && C_MissMessageMaxDist >= 0 && Event.MissDist <= C_MissMessageMaxDist) {
				declare Message = GetNearMissMessage(Event);
				if (Message != "") {
					Message::SendStatusMessage(Event.Shooter, Message, 2500, 0);
					XmlRpc::OnNearMiss(Event);
				}
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnPlayerRemoved: {
			// Player left the game
			if (G_BallObject.Position == Event.PlayerLastPosition) {
				// Drop the ball
				DropBall(Event.PlayerLastPosition);
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnPlayerTouchesObject: {
			// Player touches ball object
			if (PickUpBall(Event.Player, G_BallObject)) {
				PassOn(Event);
			} else {
				Discard(Event);
			}
		}
		case CSmModeEvent::EType::OnCommand: {
			switch (Event.CommandName) {
				case "Cmd_MapPointsClan1": {
					ClanScores[1] = Event.CommandValueInteger;
					PassOn(Event);
				}
				case "Cmd_MapPointsClan2": {
					ClanScores[2] = Event.CommandValueInteger;
					PassOn(Event);
				}
				case "Cmd_MatchPointsClan1": {
					G_ClanMapScores[1] = Event.CommandValueInteger;
					PassOn(Event);
				}
				case "Cmd_MatchPointsClan2": {
					G_ClanMapScores[2] = Event.CommandValueInteger;
					PassOn(Event);
				}
				default: {
					Discard(Event);
				}
			}
		}
		default: {
			PassOn(Event);
		}
	}
}

// Library updates #2
Top::Loop();

// Check for captures
foreach (Pole in BlockPoles) {
	// Team Goals
	if (G_ClanPoleIDs.exists(Pole.Id)) {
		if (Victory::NoRoundWinner()) {
			Pole.Gauge.Speed = -S_DefaultCaptureTime;
		}
		declare BallAtPole = False;
		if (G_BallObject.Player != Null && Pole.Sector.PlayersIds.exists(G_BallObject.Player.Id)
			&& Pole.Id == G_ClanPoleIDs[G_BallObject.Player.CurrentClan]) {
			Pole.Gauge.Speed = 1;
			if (Pole.Gauge.ValueReal < 1.) {
				UpdateCaptureTotal(G_BallObject.Player, Period);
			}
			if (Pole.Gauge.ValueReal == 0.) {
				UpdateStatCaptureTries(Pole.Gauge.Clan - 1, 1);
			}
			BallAtPole = True;
		}
		if (!BallAtPole) {
			// Prevent weird bug causing the pole stay fully captured without an OnCapture event
			if (!Pole.Captured && Pole.Gauge.ValueReal >= 1. && Now < EndTime) {
				Pole.Gauge.ValueReal = 0.;
			}
		}
		if (Pole.Gauge.ValueReal <= 0.) {
			Pole.Gauge.Max = GetCaptureTime();
		}
	}
}


// Ball stuff
switch (G_BallObject.Status) {
	case CSmObject::EStatus::InWorld: {
		if (G_BallObject.Position != BlockPoles[G_BallPoleId].Position && GetRmDrpdBallTime() <= 0) {
			// Dropped ball reset
			ResetBall();
		}
	}
	case CSmObject::EStatus::OnPlayer: {
		if (G_BallObject.Player != Null) {
			if (G_BallObject.Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
				if (Period > 0) {
					// Ball held by player
					UpdateStatBallPossession(G_BallObject.Player.CurrentClan - 1, Period);
				}
			} else {
				if (G_BallObject.Player.Position != <0., 0., 0.>) {
					// Drop ball
					DropBall(G_BallObject.Player.Position);
				} else {
					// Reset ball because of unknown position
					ResetBall();
				}
			}
		} else {
			// Dropped ball reset
			ResetBall();
		}
	}
}

// UI updates
if (G_LastUIUpdate + 240 < Now) {
	G_LastUIUpdate = Now;
	
	// Ball carrier speccing
	if (G_BallObject.Player != Null) {
		UIManager.UIAll.SpectatorAutoTarget = G_BallObject.Player.Id;
	} else {
		UIManager.UIAll.SpectatorAutoTarget = NullId;
	}
	
	// Clan scores at the top
	UpdateClanScoresSummary(False);
	
	// Update markers
	UIManager.UIAll.Hud3dMarkers = CreateHud3dMarkers();
	
	// Update net values
	UpdateNetVariables();
}

// Check round end conditions
if (Now >= EndTime) {
	// Time is up - Perform round draw
	Victory::SetRoundDrawIfNoWinner();
	MB_StopRound = True;
} else {
	if (!MB_StopRound && !Victory::NoRoundWinner()) {
		// Round winner found
		MB_StopRound = True;
	} else {
		if (Now >= UIManager.UIAll.CountdownEndTime && UIManager.UIAll.CountdownEndTime > 0) {
			// New gameplay phase!
			G_Phase += 1;
			switch (G_Phase) {
				case 1: {
					// Reduction phase began
					UIManager.UIAll.SendNotice(TextLib::Compose("$fc3%1", _("Reduction Phase!")),
						CUIConfig::ENoticeLevel::MatchWarning, Null, CUIConfig::EAvatarVariant::Default,
						CUIConfig::EUISound::PhaseChange, 0);
					UIManager.UIAll.CountdownEndTime = Now + S_TimeLimitReduction * 1000;
				}
				case 2: {
					// Instant phase began
					UIManager.UIAll.SendNotice(TextLib::Compose("$f60%1", _("Instant Phase!")),
						CUIConfig::ENoticeLevel::MatchWarning, Null, CUIConfig::EAvatarVariant::Default,
						CUIConfig::EUISound::PhaseChange, 1);
					UIManager.UIAll.CountdownEndTime = -1;
				}
			}
		}
	}
}
***

***EndRound***
***
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
MB_Sleep(2500);

G_BallObject.SetUnspawned();
SM::UnspawnAllPlayers();
StartTime = -1;
EndTime = -1;
UIManager.UIAll.CountdownEndTime = -1;
LayerMarkers.IsVisible = False;
LayerExtra.IsVisible = False;

UpdateNetVariables();

MB_Sleep(1000);

// Evaluate round
declare Message = _("Round Draw");
if (!Victory::IsRoundDraw()) {
	foreach (Index => Team in Teams) {
		if (Victory::IsRoundWinner(Index + 1)) {
			// Team 'Index' wins the round
			ClanScores[Index + 1] += 1;
			Message = TextLib::Compose(_("$<%1$> wins the Round!"), Team.ColorizedName);
			UpdateClanScoresSummary(False);
			break;
		}
	}
}
Message::CleanBigMessages();
UIManager.UIAll.SendNotice(Message,
	CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
	CUIConfig::EUISound::EndRound, 0);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

// Check match end conditions
Victory::SetMatchWinnerFromScore(S_RoundsToWin, S_RoundGapToWin, S_RoundsLimit);
if (!Victory::NoMatchWinner()) {
	// Match winner found
	MB_StopMap = True;
}

// Wait to let the players take a breath
MB_Sleep(3500);
Victory::RoundEnd();
***

***EndMap***
***
Score::MatchEnd();
ScoresTable::EndMatch();
Victory::MatchEnd();

// Destroy objects
ObjectDestroyAll();

// UI
Message::CleanAllMessages();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;

// Hide stuff
Interface::DetachRank();
LayerTeams.IsVisible = False;

// Announce victorious clan
declare Message = _("Map Draw");
if (!Victory::IsMatchDraw()) {
	foreach (Index => Team in Teams) {
		if (Victory::IsMatchWinner(Index + 1)) {
			// Team 'Index' wins the match
			Message = TextLib::Compose(_("$<%1$> wins the Map!"), Team.ColorizedName);
			G_ClanMapScores[Index + 1] += 1;
			break;
		}
	}
}
UpdateClanScoresSummary(True);
UIManager.UIAll.SendNotice(Message,
	CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, 
	CUIConfig::EUISound::EndMatch, 0);

MB_Sleep(3500);
Message::CleanAllMessages();

if (S_BestOfXMatch > 0 && G_ClanMapScores[1] + G_ClanMapScores[2] >= S_BestOfXMatch) {
	// Match over
	MB_StopMatch = True;
	declare ClanWon = [1 => False, 2 => False];
	foreach (Index => Team in Teams) {
		if (G_ClanMapScores[Index + 1] > S_BestOfXMatch * 0.5) {
			ClanWon[Index + 1] = True;
		}
	}
	Message = _("Match Draw");
	foreach (Clan => Won in ClanWon) {
		if (Won && !ClanWon[3 - Clan]) {
			Message = TextLib::Compose(_("$<%1$> wins the Match!"), Teams[Clan - 1].ColorizedName);
		}
	}
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	UIManager.UIAll.SendNotice(Message,
		CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::EndMatch, 0);
	MB_Sleep(3500);
}
***

***EndServer***
***
// UI Cleanup
ScoresTable::Unload();
Top::Unload();
TeamStats::Unload();
Interface::DestroyRank();
SpawnScreen::DestroyRules();
Bots::Unload();
UIManager.UILayerDestroyAll();
***

/*****************************************************
	FUNCTIONS
*****************************************************/

// Send hit message
Void SendHitMessage(CSmModeEvent _Event, Boolean _Pass) {
	if (_Event == Null || _Event.Shooter == Null || _Event.Victim == Null) return;
	if (_Event.Type != CSmModeEvent::EType::OnHit) return;
	declare Distance = MathLib::Distance(_Event.Shooter.Position, _Event.Victim.Position);
	if (Distance < C_HitMessageMinDist) return;
	declare UI <=> UIManager.GetUI(_Event.Shooter);
	if (UI == Null) return;
	// Send message
	declare Text Message;
	if (_Pass) {
		// Long range pass
		Message = TextLib::Compose(_("%1m pass!"), TextLib::ToText(Distance));
	} else {
		// Long range hit
		Message = TextLib::Compose(_("%1m hit!"), TextLib::ToText(Distance));
	}
	UI.SendNotice(Message,
		CUIConfig::ENoticeLevel::MapInfo, _Event.Shooter.User, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::Silence, 0);
}

// Return the capture time dependent on current phase
Integer GetCaptureTime() {
	switch (G_Phase) {
		case 1: {
			// Reduction phase
			declare LeftTime = (UIManager.UIAll.CountdownEndTime - Now + Period) * 1.;
			declare MaxTime = S_TimeLimitReduction * 1000.;
			declare Factor = LeftTime / MaxTime;
			return MathLib::CeilingInteger(S_DefaultCaptureTime * Factor);
		}
		case 2: {
			// Instant phase
			return 1;
		}
	}
	return S_DefaultCaptureTime;
}

// Returns the remaining time of the dropped ball until it resets
Integer GetRmDrpdBallTime() {
	// Calculate standard remaining time
	declare DropTime = Now;
	if (G_BallObject.Player == Null) {
		DropTime = G_BallDropTime;
	}
	declare RemainingTime = C_DroppedBallResetTime - (Now - DropTime);
	return RemainingTime;
}

// Updates global net variables
Void UpdateNetVariables() {
	declare netwrite Integer Net_StartTime for Teams[0];
	declare netwrite Integer Net_Phase for Teams[0];
	declare netwrite Text Net_BallCarrierName for Teams[0];
	declare netwrite Integer Net_BallCarrierClan for Teams[0];
	declare netwrite Boolean Net_ShowBallMarker for Teams[0];
	
	Net_StartTime = StartTime;
	Net_Phase = G_Phase;
	Net_ShowBallMarker =  (S_TimeLimitMarker <= 0 || S_TimeLimitMarker > (Now - StartTime) / 1000.);
	if (G_BallObject != Null && G_BallObject.Player != Null) {
		Net_BallCarrierName = G_BallObject.Player.Name;
		Net_BallCarrierClan = G_BallObject.Player.CurrentClan;
	} else {
		if (G_BallObject != Null && G_BallObject.Position == BlockPoles[G_BallPoleId].Position) {
			Net_BallCarrierName = " ";
		} else {
			Net_BallCarrierName = "";
		}
		Net_BallCarrierClan = 0;
		declare netwrite Integer Net_RemainingDropTime for Teams[0];
		Net_RemainingDropTime = GetRmDrpdBallTime();
	}
}

// Increase scores of the given player
Void AddPoints(CSmPlayer _Player, Integer _Points) {
	if (_Player == Null || _Player.Score == Null) return;
	_Player.Score.RoundPoints += _Points;
	_Player.Score.Points += _Points;
	ScoresTable::SetFooterScore(_Player, TextLib::Compose(_("Round: %1		Total: %2"),
		TextLib::ToText(_Player.Score.RoundPoints),
		TextLib::ToText(_Player.Score.Points)));
}

// Update damage of the given player
Void UpdateDamage(CSmPlayer _Player, Integer _Points) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Damage for _Player.Score = 0;
	declare Top_Damage for _Player.Score = 0;
	if (_Points == 0) {
		Damage = 0;
	} else {
		Damage += _Points;
		Top_Damage += _Points;
	}
	if (Top_Damage > 0) {
		ScoresTable::SetCustom2(_Player, TextLib::ToText(Damage));
		Top::SetRecord(_Player, T_Damage, TextLib::ToText(Top_Damage), -Top_Damage);
	} else {
		ScoresTable::SetCustom2(_Player, "");
	}
}

// Update passes of the given player
Void UpdatePasses(CSmPlayer _Player, Integer _Points) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Passes for _Player.Score = 0;
	declare Top_Passes for _Player.Score = 0;
	if (_Points == 0) {
		Passes = 0;
	} else {
		Passes += _Points;
		Top_Passes += _Points;
	}
	if (Passes > 0) {
		ScoresTable::SetCustom3(_Player, TextLib::ToText(Passes));
		Top::SetRecord(_Player, T_Passes, TextLib::ToText(Top_Passes), -Top_Passes);
	} else {
		ScoresTable::SetCustom3(_Player, "");
	}
}

// Update captures of the given player
Void UpdateCaptures(CSmPlayer _Player, Integer _Captures) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Top_Captures for _Player.Score = 0;
	if (_Captures == 0) {
		Top_Captures = 0;
	} else {
		Top_Captures += _Captures;
	}
	if (Top_Captures > 0) {
		Top::SetRecord(_Player, T_Captures, TextLib::ToText(Top_Captures), -Top_Captures);
	}
}

// Update ball hits of the given player
Void UpdateBallHits(CSmPlayer _Player, Integer _Hits) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Top_BallHits for _Player.Score = 0;
	if (_Hits == 0) {
		Top_BallHits = 0;
	} else {
		Top_BallHits += _Hits;
	}
	if (Top_BallHits > 0) {
		Top::SetRecord(_Player, T_BallHitters, TextLib::ToText(Top_BallHits), -Top_BallHits);
	}
}

// Update back stabs of the given player
Void UpdateBackStabs(CSmPlayer _Player, Integer _Stabs) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Top_BackStabs for _Player.Score = 0;
	if (_Stabs == 0) {
		Top_BackStabs = 0;
	} else {
		Top_BackStabs += _Stabs;
	}
	if (Top_BackStabs > 0) {
		Top::SetRecord(_Player, T_BackStabber, TextLib::ToText(Top_BackStabs), -Top_BackStabs);
	}
}

// Update capture % sum of the given player
Void UpdateCaptureTotal(CSmPlayer _Player, Integer _Progress) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Top_CaptureSum for _Player.Score = 0;
	if (_Progress == 0) {
		Top_CaptureSum = 0;
	} else {
		Top_CaptureSum += _Progress;
	}
	if (Top_CaptureSum > 0) {
		declare CaptureProgress = MathLib::NearestInteger(100. * MathLib::ToReal(Top_CaptureSum) / MathLib::ToReal(S_DefaultCaptureTime));
		Top::SetRecord(_Player, T_CaptureTotal, TextLib::ToText(CaptureProgress)^"%", -CaptureProgress);
	}
}

// Reset all match tops
Void ResetMatchTops() {
	foreach (Player in AllPlayers) {
		if (Player.Score == Null) continue;
		
		declare Integer Top_Damage for Player.Score;
		declare Integer Top_Passes for Player.Score;
		declare Integer Top_Captures for Player.Score;
		declare Integer Top_BallHits for Player.Score;
		declare Integer Top_BackStabs for Player.Score;
		declare Integer Top_CaptureSum for Player.Score;
		
		Top_Damage = 0;
		Top_Passes = 0;
		Top_Captures = 0;
		Top_BallHits = 0;
		Top_BackStabs = 0;
		Top_CaptureSum = 0;
		
		UpdatePasses(Player, 0);
		UpdateCaptures(Player, 0);
		UpdateDamage(Player, 0);
		UpdateBallHits(Player, 0);
		UpdateBackStabs(Player, 0);
		UpdateCaptureTotal(Player, 0);
	}
}

// Reset all round tops
Void ResetRoundTops() {
	foreach (Player in AllPlayers) {
		if (Player.Score == Null) continue;
		AddPoints(Player, 0);
		UpdatePasses(Player, 0);
		UpdateDamage(Player, 0);
	}
}

// Update teams ball possession
Void UpdateStatBallPossession(Integer _Clan, Integer _Time) {
	if (!Teams.existskey(_Clan) || !Teams.existskey(1 - _Clan)) return;
	declare Stat_BallPoss as Stat_BallPoss0 for Teams[_Clan] = 0;
	if (_Time == 0) {
		Stat_BallPoss0 = 0;
		TeamStats::SetStat(T_BallPoss, _Clan, "0%");
		TeamStats::SetStat(T_BallPoss, 1 - _Clan, "0%");
	} else {
		Stat_BallPoss0 += _Time;
		declare Possession = 0;
		if (Stat_BallPoss0 > 0) {
			declare Stat_BallPoss as Stat_BallPoss1 for Teams[1 - _Clan] = 0;
			Possession = MathLib::NearestInteger((100. * Stat_BallPoss0) / (1. * (Stat_BallPoss0 + Stat_BallPoss1)));
		}
		TeamStats::SetStat(T_BallPoss, _Clan, TextLib::Compose("%1%2", TextLib::ToText(Possession), "%"));
		TeamStats::SetStat(T_BallPoss, 1 - _Clan, TextLib::Compose("%1%2", TextLib::ToText(100 - Possession), "%"));
	}
}

// Update teams damage
Void UpdateStatDamage(Integer _Clan, Integer _Damage) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_Damage for Teams[_Clan] = 0;
	if (_Damage == 0) {
		Stat_Damage = 0;
	} else {
		Stat_Damage += _Damage;
	}
	TeamStats::SetStat(T_Damage, _Clan, TextLib::ToText(Stat_Damage));
}

// Update teams passes
Void UpdateStatPasses(Integer _Clan, Integer _Passes) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_Passes for Teams[_Clan] = 0;
	if (_Passes == 0) {
		Stat_Passes = 0;
	} else {
		Stat_Passes += _Passes;
	}
	TeamStats::SetStat(T_Passes, _Clan, TextLib::ToText(Stat_Passes));
}

// Update teams capture tries
Void UpdateStatCaptureTries(Integer _Clan, Integer _Tries) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_CaptureTries for Teams[_Clan] = 0;
	if (_Tries == 0) {
		Stat_CaptureTries = 0;
	} else {
		Stat_CaptureTries += _Tries;
	}
	TeamStats::SetStat(T_CaptureTries, _Clan, TextLib::ToText(Stat_CaptureTries));
}

// Update teams enemy kills
Void UpdateStatEnemyKills(Integer _Clan, Integer _Kills) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_EnemyKills for Teams[_Clan] = 0;
	if (_Kills == 0) {
		Stat_EnemyKills = 0;
	} else {
		Stat_EnemyKills += _Kills;
	}
	TeamStats::SetStat(T_EnemyKills, _Clan, TextLib::ToText(Stat_EnemyKills));
}

// Update teams team kills
Void UpdateStatTeamKills(Integer _Clan, Integer _Kills) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_TeamKills for Teams[_Clan] = 0;
	if (_Kills == 0) {
		Stat_TeamKills = 0;
	} else {
		Stat_TeamKills += _Kills;
	}
	TeamStats::SetStat(T_TeamKills, _Clan, TextLib::ToText(Stat_TeamKills));
}

// Reset team statistics
Void ResetStatistics() {
	foreach (Clan => Team in Teams) {
		UpdateStatBallPossession(Clan, 0);
		UpdateStatDamage(Clan, 0);
		UpdateStatPasses(Clan, 0);
		UpdateStatCaptureTries(Clan, 0);
		UpdateStatEnemyKills(Clan, 0);
		UpdateStatTeamKills(Clan, 0);
	}
}

// Spawn player
Void MySpawnPlayer(CSmPlayer _Player) {
	if (_Player == Null) return;
	UnspawnPlayer(_Player);
	if (_Player.RequestsSpectate) return;
	
	// Set player weapon
	switch (S_Mode) {
		case 1: {
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
		}
		case 2: {
			declare WeaponNb = MathLib::Rand(1, 4);
			switch (WeaponNb) {
				case 2: {
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, True);
				}
				case 3: {
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, True);
				}
				case 4: {
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Arrow, True);
				}
				default: {
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
				}
			}
		}
		default: {
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
		}
	}
	
	// Calculate spawn time
	declare SpawnTime = StartTime;
	if (Now > SpawnTime) {
		SpawnTime = Now + 3000;
	}
	
	// Determine spawn block
	declare SpawnIds = G_ClanSpawnIDs[_Player.RequestedClan];
	declare SpawnIndex = 0;
	if (G_LastSpawnIndex.existskey(_Player.RequestedClan)) {
		SpawnIndex = G_LastSpawnIndex[_Player.RequestedClan] + 1;
		if (SpawnIndex >= SpawnIds.count) {
			SpawnIndex = 0;
		}
	}
	G_LastSpawnIndex[_Player.RequestedClan] = SpawnIndex;
	SM::SpawnPlayer(_Player, _Player.RequestedClan, BlockSpawns[SpawnIds[SpawnIndex]], SpawnTime);
}

// Set clans of spawns and poles at start of map and each round (changing sides)
Void AssignSpawnPoleClans() {
	// SPAWNS
	// Change sides
	declare FirstSpawns = G_ClanSpawnIDs[1];
	G_ClanSpawnIDs[1] = G_ClanSpawnIDs[2];
	G_ClanSpawnIDs[2] = FirstSpawns;
	// Assign clans
	foreach (Clan => SpawnIds in G_ClanSpawnIDs) {
		foreach (Index => Id in SpawnIds) {
			switch (BlockSpawns[Id].Base.Clan) {
				case 0: {
					if (Clan != 3) {
						BlockSpawns[Id].Base.Clan = Clan;
					}
				}
				default: {
					BlockSpawns[Id].Base.Clan = 3 - BlockSpawns[Id].Base.Clan;
				}
			}
		}
	}
	
	// POLES
	// Edit ball pole
	if (BlockPoles.existskey(G_BallPoleId)) {
		BlockPoles[G_BallPoleId].Base.Clan = 0;
		BlockPoles[G_BallPoleId].Gauge.Clan = 0;
	}
	
	// Change sides
	declare FirstPole = G_ClanPoleIDs[1];
	G_ClanPoleIDs[1] = G_ClanPoleIDs[2];
	G_ClanPoleIDs[2] = FirstPole;
	// Prepare poles stuff
	foreach (Order => Id in G_ClanPoleIDs) {
		// Initialize values
		BlockPoles[Id].Captured = False;
		BlockPoles[Id].Gauge.ValueReal = 0.;
		BlockPoles[Id].Gauge.Speed = 0;
		
		// Assign clans
		switch (BlockPoles[Id].Gauge.Clan) {
			case 0: {
				if (Order != 3) {
					BlockPoles[Id].Gauge.Clan = Order;
					BlockPoles[Id].Base.Clan = BlockPoles[Id].Gauge.Clan;
				}
			}
			default: {
				BlockPoles[Id].Gauge.Clan = 3 - BlockPoles[Id].Gauge.Clan;
				BlockPoles[Id].Base.Clan = BlockPoles[Id].Gauge.Clan;
			}
		}
	}
}

// Update clans of bases
Void UpdateBaseClans() {
	if (G_BallObject.Player == Null) {
		// Ball dropped - Reset base clan of the ball pole
		if (BlockPoles.existskey(G_BallPoleId)) {
			BlockPoles[G_BallPoleId].Base.Clan = 0;
			BlockPoles[G_BallPoleId].Gauge.Clan = 0;
		}
	} else {
		// A clan carries the ball - Set carrying clan to ball pole
		if (BlockPoles.existskey(G_BallPoleId)) {
			BlockPoles[G_BallPoleId].Base.Clan = G_BallObject.Player.CurrentClan;
			BlockPoles[G_BallPoleId].Gauge.Clan = G_BallObject.Player.CurrentClan;
		}
		// Bases screw things up on some maps - Perform fix if needed
		if (G_ClanPoleIDs.existskey(1) && G_ClanPoleIDs.existskey(2)
			&& BlockPoles.existskey(G_ClanPoleIDs[1]) && BlockPoles.existskey(G_ClanPoleIDs[2])) {
			if (BlockPoles[G_ClanPoleIDs[1]].Base == BlockPoles[G_ClanPoleIDs[2]].Base) {
				// Poles of the teams share the same base -.-
				// Change the clan of the base to the clan currently carrying the ball
				BlockPoles[G_ClanPoleIDs[G_BallObject.Player.CurrentClan]].Base.Clan = G_BallObject.Player.CurrentClan;
			}
		}
	}
}

// Player picks up the ball
Boolean PickUpBall(CSmPlayer _Player, CSmObject _Object) {
	// Perform several checks if picking up is allowed right now because of weird bugs of the game itself
	if (_Player == Null || _Object == Null || _Object.Player != Null || _Object != G_BallObject) return False;
	if ((Now > EndTime && EndTime > StartTime) || Now < StartTime) return False;
	if (_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || _Player.Armor <= 0) return False;
	if (!C_BotsCanHaveBall && _Player.IsFakePlayer) return False;
				
	_Object.SetPlayer(_Player);
	
	Message::SendBigMessage(TextLib::Compose(_("$<%1$> has the $<%2Ball$>!"), _Player.Name, Teams[_Player.CurrentClan - 1].ColorText),
		3000, 2, CUIConfig::EUISound::PhaseChange, 0);
	AddPoints(_Player, 2);
	UpdateBaseClans();
	
	return True;
}

Void ResetBall() {
	G_BallObject.SetPosition(BlockPoles[G_BallPoleId].Position);
	Message::SendBigMessage(_("The Ball has been reset!"), 3000, 1, CUIConfig::EUISound::PhaseChange, 1);
	UpdateBaseClans();
}

// Ball carrier drops the ball
Void DropBall(Vec3 _Position) {
	if (G_BallObject.Player == Null) return;
	declare Message = TextLib::Compose(_("$<%1$> dropped the Ball!"), G_BallObject.Player.Name);
	
	G_BallObject.SetPosition(_Position);
	
	// Perform drop
	Message::SendBigMessage(Message, 3000, 2, CUIConfig::EUISound::PhaseChange, 0);
	G_BallDropTime = Now;
	G_LastBallResetSeconds = MathLib::CeilingInteger(C_DroppedBallResetTime / 1000.);
	UpdateBaseClans();
}

// Player gets passed the ball
Void PassBall(CSmPlayer _Shooter, CSmPlayer _Victim) {
	// Perform several checks if passing is allowed right now because of weird event bugs of the game itself
	if (_Shooter == Null || _Victim == Null) return;
	if (Now < StartTime || StartTime < 0) return;
	if (G_BallObject.Player != _Shooter || _Shooter.Armor <= 0) return;
	if (_Victim.StartTime > Now || _Victim.Armor <= 0 || (!C_BotsCanHaveBall && _Victim.IsFakePlayer)) return;
	
	G_BallObject.SetPlayer(_Victim);
	
	Message::SendBigMessage(TextLib::Compose(_("$<%1$> has the $<%2Ball$>!"), G_BallObject.Player.Name,
		Teams[G_BallObject.Player.CurrentClan-1].ColorText), 3000, 2, CUIConfig::EUISound::Warning, 0);
	
	if (_Shooter.CurrentClan == _Victim.CurrentClan) {
		// Team pass -> Grant points!
		AddPoints(_Shooter, 2);
		UpdatePasses(_Shooter, 1);
		UpdateStatPasses(_Shooter.CurrentClan - 1, 1);
		if (!_Shooter.IsFakePlayer) {
			XmlRpc.SendCallback("passBall", "Shooter:"^_Shooter.Login^";Victim:"^_Victim.Login);
		}
	} else {
		// Pass to opponent
		UpdateBaseClans();
	}
}

// Updates clan scores at the top
Void UpdateClanScoresSummary(Boolean _Tolerant) {
	declare PlayerClan1Id = NullId;
	declare PlayerClan2Id = NullId;
	foreach (Player in Players) {
		if (PlayerClan1Id == NullId && (Player.CurrentClan == 1 || _Tolerant && Player.RequestedClan == 1)) {
			PlayerClan1Id = Player.Id;
		} else {
			if (PlayerClan2Id == NullId && (Player.CurrentClan == 2 || _Tolerant && Player.RequestedClan == 2)) {
				PlayerClan2Id = Player.Id;
			} else {
				if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
					break;
				}
			}
		}
	}
	if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
		UIManager.UIAll.OverlayScoreSummary = True;
		UIManager.UIAll.ScoreSummary_Player1 = PlayerClan1Id;
		UIManager.UIAll.ScoreSummary_Points1 = ClanScores[Players[PlayerClan1Id].RequestedClan];
		UIManager.UIAll.ScoreSummary_Player2 = PlayerClan2Id;
		UIManager.UIAll.ScoreSummary_Points2 = ClanScores[Players[PlayerClan2Id].RequestedClan];
		if (S_BestOfXMatch > 0) {
			UIManager.UIAll.ScoreSummary_MatchPoints1 = G_ClanMapScores[Players[PlayerClan1Id].RequestedClan];
			UIManager.UIAll.ScoreSummary_MatchPoints2 = G_ClanMapScores[Players[PlayerClan2Id].RequestedClan];
		} else {
			UIManager.UIAll.ScoreSummary_MatchPoints1 = -1;
			UIManager.UIAll.ScoreSummary_MatchPoints2 = -1;
		}
	} else {
		if (!_Tolerant) {
			UpdateClanScoresSummary(True);
		} else {
			UIManager.UIAll.OverlayScoreSummary = False;
		}
	}
}

// Create the extra layer manialink
Text CreateLayerExtra() {
	declare BarImageUrl = "file://Media/Images/Common/GreenBar.png";
	declare Manialink = """<script><!--
		#Include "MathLib" as MathLib
		#Include "TextLib" as TextLib
		
		main() {
			wait(InputPlayer != Null);
				
			declare Label_Phase					<=> (Page.GetFirstChild("Label_Phase") as CMlLabel);
			declare Quad_BallCarrierHighlight	<=> (Page.GetFirstChild("Quad_BallCarrierHighlight") as CMlQuad);
			
			declare Frame_BallCarrier		<=> (Page.GetFirstChild("Frame_BallCarrier") as CMlFrame);
			declare Label_BallCarrier		<=> (Frame_BallCarrier.GetFirstChild("Label_BallCarrier") as CMlLabel);
			declare Frame_TeamBar			<=> (Frame_BallCarrier.GetFirstChild("Frame_TeamBar") as CMlFrame);
			declare Quads_TeamBar1			<=> (Frame_TeamBar.GetFirstChild("Quad_TeamBar1") as CMlQuad);
			declare Quads_TeamBar2			<=> (Frame_TeamBar.GetFirstChild("Quad_TeamBar2") as CMlQuad);
			
			declare Frame_Crosshair			<=> (Page.GetFirstChild("Frame_Crosshair") as CMlFrame);
			declare Label_CrosshairTop		<=> (Frame_Crosshair.GetFirstChild("Label_CrosshairTop") as CMlLabel);
			declare Label_CrosshairBottom	<=> (Frame_Crosshair.GetFirstChild("Label_CrosshairBottom") as CMlLabel);
			
			declare Frame_Capturing			<=> (Page.GetFirstChild("Frame_Capturing") as CMlFrame);
			declare Label_Capturing			<=> (Frame_Capturing.GetFirstChild("Label_Capturing") as CMlLabel);
			declare Gauge_Capturing			<=> (Frame_Capturing.GetFirstChild("Gauge_Capturing") as CMlGauge);
			
			declare ShowHighlight for LocalUser = True;
			
			declare netread Net_BallPoleIndex for Teams[0] = -1;
			
			declare netread Net_StartTime for Teams[0] = -1;
			declare netread Net_Phase for Teams[0] = -1;
			
			declare netread Net_BallCarrierClan for Teams[0] = 0;
			declare netread Net_BallCarrierName for Teams[0] = "";
			declare netread Net_RemainingDropTime for Teams[0] = 0;
			
			declare LastCapturedTime = -1;
			
			declare LastUIUpdate = 0;
			
			while (True) {
				yield;
				
				declare ThisPlayer <=> InputPlayer;
				if (GUIPlayer != Null) ThisPlayer <=> GUIPlayer;
				
				foreach (Event in PendingEvents) {
					switch (Event.Type) {
						case CMlEvent::Type::KeyPress: {
							switch (Event.KeyCode) {
								case 39: {
									ShowHighlight = !ShowHighlight;
								}
							}
						}
					}
				}
				
				// Capturing gauge
				declare ShowGauge = False;
				if ((Net_StartTime > 0 && Net_StartTime < ArenaNow) || LastCapturedTime > 0) {
					foreach (Index => Pole in BlockPoles) {
						if (Index == Net_BallPoleIndex || Net_BallPoleIndex < 0) continue;
						if (Pole.Gauge.ValueReal <= 0.) continue;
						declare Value = MathLib::FloorInteger(Pole.Gauge.ValueReal * 100.);
						if (Value <= 0) continue;
						if (Value >= 100 && !Pole.Captured) {
							Value -= 1;
						}
						Label_Capturing.Value = Value^"%";
						Gauge_Capturing.SetRatio(Pole.Gauge.ValueReal);
						Gauge_Capturing.SetClan(Pole.Gauge.Clan);
						LastCapturedTime = Now;
						if (Pole.Captured) {
							LastCapturedTime += 500;
						}
						break;
					}
				}
				if (LastCapturedTime + 650 > Now) {
					ShowGauge = True;
				} else {
					LastCapturedTime = -1;
				}
				Frame_Capturing.Visible = ShowGauge;
				
				if (LastUIUpdate + 250 > Now) continue;
				LastUIUpdate = Now;
				
				// Hide stuff between rounds
				Frame_BallCarrier.Visible = (Net_StartTime > 0);
				
				// Phase display
				if (Net_StartTime < 0 || Net_Phase < 0 && Net_Phase > 2) {
					Label_Phase.Visible = False;
				} else {
					Label_Phase.Visible = True;
					switch (Net_Phase) {
						case 1: {
							Label_Phase.Value = TextLib::Compose(_("%1Reduction Phase!"), "$fc3");
						}
						case 2: {
							Label_Phase.Value = TextLib::Compose(_("%1Instant Phase!"), "$f60");
						}
						default: {
							Label_Phase.Value = _("Normal Phase");
						}
					}
				}
				
				// Crosshair extension
				if (Net_StartTime > 0 && ThisPlayer.Name == Net_BallCarrierName && Teams.existskey(Net_BallCarrierClan - 1)) {
					Frame_Crosshair.Visible = True;
					Label_CrosshairTop.Value = Teams[Net_BallCarrierClan - 1].ColorText^"〝      〞";
					Label_CrosshairBottom.Value = TextLib::Compose(_("%1shoot to pass"), Teams[Net_BallCarrierClan - 1].ColorText^"$n$o");
					Quad_BallCarrierHighlight.Visible = (True && ShowHighlight);
					Quad_BallCarrierHighlight.Colorize = Teams[Net_BallCarrierClan - 1].ColorPrimary;
				} else {
					Frame_Crosshair.Visible = False;
					Quad_BallCarrierHighlight.Visible = False;
				}
				
				// Ball carrier display
				switch (Net_BallCarrierName) {
					case " ": {
						Frame_TeamBar.Visible = False;
						Label_BallCarrier.Value = _("Home");
					}
					case "": {
						Frame_TeamBar.Visible = False;
						Label_BallCarrier.Value = TextLib::Compose(_("Dropped (%1)"), TextLib::ToText(Net_RemainingDropTime / 1000 + 1));
					}
					default: {
						if (Teams.existskey(Net_BallCarrierClan - 1)) {
							Frame_TeamBar.Visible = True;
							foreach (Control in Frame_TeamBar.Controls) {
								declare Quad <=> (Control as CMlQuad);
								Quad.Colorize = Teams[Net_BallCarrierClan - 1].ColorPrimary;
							}
							Label_BallCarrier.Value = Teams[Net_BallCarrierClan - 1].ColorText^"$<"^Net_BallCarrierName^"$>";
						} else {
							Frame_TeamBar.Visible = False;
							Label_BallCarrier.Value = Net_BallCarrierName;
						}
					}
				}
			}
		}
		--></script>
		<label id="Label_Phase" posn="0 89 50" sizen="30 0" textsize="1" scale="0.8" hidden="1" halign="center" valign="center2"/>
		<quad id="Quad_BallCarrierHighlight" posn="0 0 -30" sizen="320 180" hidden="1" halign="center" valign="center2"
			image="file://Media/Images/SpeedBall/BallCarrierFilter1.png" opacity="0.6"/>
		
		<frame id="Frame_BallCarrier" posn="110 -65" hidden="1">
			<quad posn="0 0 0" sizen="55 8" style="Bgs1InRace" substyle="BgWindow3" halign="center" valign="center2"/>
			<label id="Label_BallCarrier" posn="0 0 2" sizen="50 7" textprefix="$000" halign="center" valign="center2"/>
			<frame id="Frame_TeamBar" hidden="1">
				<quad id="Quad_TeamBar1" posn="-26 0 1" sizen="1 6" image="{{{BarImageUrl}}}" opacity="0.9" halign="center" valign="center2"/>
				<quad id="Quad_TeamBar2" posn="26 0 1" sizen="1 6" image="{{{BarImageUrl}}}" opacity="0.9" halign="center" valign="center2"/>
			</frame>
		</frame>
		
		<frame id="Frame_Crosshair" hidden="1">
			<label id="Label_CrosshairTop" posn="0 7" scale="2" halign="center" valign="center2"/>
			<label id="Label_CrosshairBottom" posn="0 -8.5" scale="1" style="TextCardSmallScores2" halign="center" valign="center2"/>
		</frame>
		
		<frame id="Frame_Capturing" hidden="1">
			<label id="Label_Capturing" posn="0 -25" scale="2" textprefix="$o" halign="center" valign="center2"/>
			<gauge id="Gauge_Capturing" posn="0 -35" sizen="110 8" style="EnergyBar" halign="center" valign="center2"/>
		</frame>""";
	return Manialink;
}

// Creates message for near miss
Text GetNearMissMessage(CSmModeEvent _Event) {
	// Catch invalid events
	if (_Event.Type != CSmModeEvent::EType::OnNearMiss) return "";						// Wrong event type
	if (_Event.MissDist <= 0. || _Event.MissDist > C_MissMessageMaxDist) return "";		// Invalid miss distance
	if (_Event.Victim == Null) return "";												// Invalid victim
	
	// Get message text
	declare Message = "";
	declare Dist = MathLib::NearestInteger(_Event.MissDist * 1000.);
	if (Dist >= 10.) {
		Message = (Dist / 10.)^"cm!";
	} else {
		Dist = MathLib::NearestInteger(_Event.MissDist * 10000.);
		if (Dist >= 10.) {
			Message = (Dist / 10.)^"mm!";
		} else {
			Dist = MathLib::NearestInteger(_Event.MissDist * 10000000.);
			Message = (Dist / 10.)^"µm!";
		}
	}
	return TextLib::Compose(_("You missed $<%1$> by %2"), _Event.Victim.Name, Message);
}

// Get the current rankings for xmlrpc callbacks
Text GetRankings() {
	declare PlayerList = "";
	foreach (Score in Scores) {
		if (Score.User.IsFakeUser) continue;
		PlayerList ^= Score.User.Login^":"^Score.Points^";";
	}
	return PlayerList;
}

// Update hud3dmarkers
Text CreateHud3dMarkers() {
	declare Markers = "";
	
	// Spawn markers
	if (G_BallObject.Player != Null) {
		if (!G_BallObject.Player.IsBot) {
			// Normal player
			Markers ^= """
				<marker playerlogin="{{{G_BallObject.Player.Login}}}" manialinkframeid="Frame_BallMarker"/>
				<marker playerlogin="{{{G_BallObject.Player.Login}}}" manialinkframeid="Frame_BallMarkerHelp" visibility="Never"/>""";
		} else {
			// Bot
			Markers ^= """
				<marker manialinkframeid="Frame_BallMarker" box="0 1.7 0"
					pos="{{{G_BallObject.Player.Position[0]}}} {{{G_BallObject.Player.Position[1]}}} {{{G_BallObject.Player.Position[2]}}}"/>
				<marker manialinkframeid="Frame_BallMarkerHelp" visibility="Never" box="0 1.7 0"
					pos="{{{G_BallObject.Player.Position[0]}}} {{{G_BallObject.Player.Position[1]}}} {{{G_BallObject.Player.Position[2]}}}"/>""";
		}
	} else {
		// Dropped
		Markers ^= """
			<marker manialinkframeid="Frame_BallMarker"
				pos="{{{G_BallObject.Position[0]}}} {{{G_BallObject.Position[1]}}} {{{G_BallObject.Position[2]}}}"/>
			<marker manialinkframeid="Frame_BallMarkerHelp" visibility="WhenInMiddleOfScreen"
				pos="{{{G_BallObject.Position[0]}}} {{{G_BallObject.Position[1]}}} {{{G_BallObject.Position[2]}}}"/>""";
	}//None,Never,Always,WhenInFrustum,WhenVisible,WhenInMiddleOfScreen
	
	// Pole markers
	foreach (Pole in BlockPoles) {
		if (Pole.Order == 1 || Pole.Order == 2) {
			Markers ^= """
				<marker manialinkframeid="Frame_PoleMarker{{{Pole.Order}}}" box="0 6 0" visibility="WhenInFrustum"
					pos="{{{Pole.Position[0]}}} {{{Pole.Position[1]}}} {{{Pole.Position[2]}}}"/>""";
		}
	}
	
	return Markers;
}

// Create markers layer manialink
Text CreateMarkersLayer() {
	declare BallImageSize = 0.4;
	declare Manialink = """<script><!--
		#Include "TextLib" as TextLib

		main() {
			wait(InputPlayer != Null);
			
			declare Frame_BallMarkerHelp	<=> (Page.GetFirstChild("Frame_BallMarkerHelp") as CMlFrame);
			declare Frame_BallMarker		<=> (Page.GetFirstChild("Frame_BallMarker") as CMlFrame);
			declare Label_BallMarker		<=> (Frame_BallMarker.GetFirstChild("Label_BallMarker") as CMlLabel);
			declare Quad_BallMarker			<=>	(Frame_BallMarker.GetFirstChild("Quad_BallMarker") as CMlQuad);
			
			declare Frame_PoleMarker1		<=> (Page.GetFirstChild("Frame_PoleMarker1") as CMlFrame);
			declare Frame_PoleMarker2		<=> (Page.GetFirstChild("Frame_PoleMarker2") as CMlFrame);
			declare Label_PoleMarker1		<=> (Frame_PoleMarker1.GetFirstChild("Label_PoleMarker") as CMlLabel);
			declare Label_PoleMarker2		<=> (Frame_PoleMarker2.GetFirstChild("Label_PoleMarker") as CMlLabel);
			
			declare netread Net_BallCarrierClan		for Teams[0] = 0;
			declare netread Net_RemainingDropTime	for Teams[0] = 0;
			declare netread Net_ShowBallMarker		for Teams[0] = True;
			
			declare BallMarkerImageUrls = [	"file://Media/Images/SpeedBall/BallLogo.png",
											"file://Media/Images/SpeedBall/BallLogoo.png"];
			
			declare LastUIUpdate = 0;
			declare LastUIUpdate2 = 0;
			declare LastBallMarkerUpdate = 0;
			declare Ident[Integer] PoleIds;
			
			while (True) {
				yield;
				
				if (LastUIUpdate + 200 > Now) continue;
				LastUIUpdate = Now;
				
				declare ThisPlayer <=> InputPlayer;
				if (GUIPlayer != Null) ThisPlayer <=> GUIPlayer;
				
				declare UpdatePoles = False;
				if (PoleIds.count <= 0) {
					UpdatePoles = True;
				} else {
					foreach (PoleId in PoleIds) {
						if (!BlockPoles.existskey(PoleId)) {
							UpdatePoles = True;
							break;
						}
					}
				}
				if (UpdatePoles) {
					PoleIds.clear();
					foreach (Pole in BlockPoles) {
						if (Pole.Order == 1 || Pole.Order == 2) {
							PoleIds[Pole.Order] = Pole.Id;
						}
					}
				}
				
				// Update ball marker
				Quad_BallMarker.Visible = !Frame_BallMarkerHelp.Visible && (Net_ShowBallMarker || IsSpectatorMode
					|| !Teams.existskey(Net_BallCarrierClan - 1) || ThisPlayer.CurrentClan == Net_BallCarrierClan);
				if (Teams.existskey(Net_BallCarrierClan - 1)) {
					// Team color
					Quad_BallMarker.Colorize = Teams[Net_BallCarrierClan - 1].ColorPrimary;
				} else {
					// White neutral color
					Quad_BallMarker.Colorize = <1., 1., 1.>;
				}
				
				// Show remaining drop time
				if (Net_BallCarrierClan == 0 && Net_RemainingDropTime > 0) {
					Label_BallMarker.Value = TextLib::ToText((Net_RemainingDropTime + 300) / 1000);
				} else {
					Label_BallMarker.Value = "";
				}
				
				if (LastUIUpdate2 + 5000 > Now) continue;
				LastUIUpdate2 = Now;
				
				// Update pole markers
				foreach (Order => Id in PoleIds) {
					declare TextValue = "";
					declare PoleClan = BlockPoles[Id].Gauge.Clan;
					if (Teams.existskey(PoleClan - 1)) {
						if (IsSpectatorMode) {
							TextValue = TextLib::Compose("%1%2 %3", Teams[PoleClan - 1].ColorizedName, Teams[PoleClan - 1].ColorText, _("Attack"));
						} else {
							declare Action = _("Defend");
							if (BlockPoles[Id].Gauge.Clan == ThisPlayer.CurrentClan) {
								Action = _("Attack");
							}
							TextValue = TextLib::Compose("%1%2", Teams[PoleClan - 1].ColorText, Action);
						}
					}
					switch (Order) {
						case 1: {
							Label_PoleMarker1.Value = TextValue;
						}
						case 2: {
							Label_PoleMarker2.Value = TextValue;
						}
					}
				}
				
				if (LastBallMarkerUpdate + 60000 > Now) continue;
				LastBallMarkerUpdate = Now;
				
				// Update ball marker image (in order to prevent a bug -.-)
				foreach (Index => Url in BallMarkerImageUrls) {
					if (Quad_BallMarker.ImageUrl == "" || Quad_BallMarker.ImageUrl == Url) {
						Quad_BallMarker.ImageUrl = BallMarkerImageUrls[1 - Index];
						break;
					}
				}
			}
		}
		--></script>
		<frame id="Frame_BallMarkerHelp" hidden="1"/>>
		<frame id="Frame_BallMarker" hidden="1">
			<label id="Label_BallMarker" sizen="9 16" posn="0.1 5.5" scale="0.9" textprefix="$f05" halign="center" valign="bottom"/>
			<quad id="Quad_BallMarker" sizen="{{{9. * BallImageSize}}} {{{16. * BallImageSize}}}" halign="center" valign="bottom"/>
		</frame>
		<framemodel id="Frame_PoleMarkerFrame">
			<label id="Label_PoleMarker" posn="0 4" textsize="2" scale="0.8" halign="center" valign="center2"/>
			<quad posn="0 4" sizen="16 4" style="BgsPlayerCard" substyle="BgMediaTracker" halign="center" valign="center2"/>
			<quad posn="0 2 1" sizen="4 8.5" opacity="0.4" halign="center" valign="center2" colorize="1 1 1"
				image="file://Media/Manialinks/ShootMania/Common/target.dds"/>
		</framemodel>
		<frameinstance id="Frame_PoleMarker1" modelid="Frame_PoleMarkerFrame" hidden="1"/>
		<frameinstance id="Frame_PoleMarker2" modelid="Frame_PoleMarkerFrame" hidden="1"/>""";
	return Manialink;
}

// Check for changes of the script settings
Void CheckSettings() {
	declare UpdateRules = False;
	declare UpdateFooter = False;
	
	// Check friendly fire setting
	declare Last_FriendlyFire for This = S_FriendlyFire;
	if (Last_FriendlyFire != S_FriendlyFire) {
		if (S_FriendlyFire) {
			UIManager.UIAll.SendChat("$<$f80Friendly Fire$> is now $<$0f0activated$>! (Pay attention to not damage your team mates!)");
		} else {
			UIManager.UIAll.SendChat("$<$f80Friendly Fire$> is now $<$f11deactivated$>!");
		}
		Last_FriendlyFire = S_FriendlyFire;
		UpdateRules = True;
	}
	
	// Check gameplay mode setting
	declare Last_Mode for This = S_Mode;
	if (Last_Mode != S_Mode) {
		switch (S_Mode) {
			case 1: {
				UIManager.UIAll.SendChat("$<$f80Laser Mode$> is now $<$0f0activated$>! (Players spawn with lasers!)");
			}
			case 2: {
				UIManager.UIAll.SendChat("$<$f80Random Mode$> is now $<$0f0activated$>! (Players spawn with random weapons!)");
			}
			default: {
				UIManager.UIAll.SendChat("$<$f80Normal Mode$> is now $<$0f0activated$>!");
			}
		}
		Last_Mode = S_Mode;
		UpdateRules = True;
	}
	
	// Check rounds to win setting
	declare Last_RoundsToWin for This = S_RoundsToWin;
	if (Last_RoundsToWin != S_RoundsToWin) {
		Last_RoundsToWin = S_RoundsToWin;
		UpdateFooter = True;
	}
	
	// Check rounds limit setting
	declare Last_RoundsLimit for This = S_RoundsLimit;
	if (Last_RoundsLimit != S_RoundsLimit) {
		Last_RoundsLimit = S_RoundsLimit;
		UpdateFooter = True;
	}
	
	// Check marker limit setting
	declare Last_MarkerLimit for This = S_TimeLimitMarker;
	if (Last_MarkerLimit != S_TimeLimitMarker) {
		Last_MarkerLimit = S_TimeLimitMarker;
		UpdateRules = True;
	}
	
	// Announce hidden marker?
	declare netwrite Net_ShowBallMarker for Teams[0] = True;
	declare Last_ShowMarker for This = True;
	if (Last_ShowMarker != Net_ShowBallMarker) {
		Last_ShowMarker = Net_ShowBallMarker;
		if (!Net_ShowBallMarker) {
			Message::SendStatusMessage(TextLib::Compose("$fc0%1", _("The Ball marker is now hidden!")), 4000, 2);
		}
	}
	
	// Reset clan map scores?
	declare Last_BestOfXMaps for This = S_BestOfXMatch;
	if (Last_BestOfXMaps != S_BestOfXMatch) {
		if (Last_BestOfXMaps <= 0 && S_BestOfXMatch > 0) {
			G_ClanMapScores = [1 => 0, 2 => 0];
		}
		Last_BestOfXMaps = S_BestOfXMatch;
	}
	
	// Update rules or footer?
	if (UpdateRules) {
		---Rules---
	}
	if (UpdateFooter) {
		foreach (Player in Players) {
			ScoresTable::SetFooterStats(Player, TextLib::Compose(_("Rounds to win: %1 (Limit: %2)"),
				TextLib::ToText(Last_RoundsToWin), TextLib::ToText(Last_RoundsLimit)));
		}
	}
}
