/****************************************
*	Tjost Game Mode						*
*	Author:		steeffeen				*
*	Contact:	schteffens@gmail.com	*
****************************************/

/*
TODO:
*/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"TjostArena,SpeedBallArena"
#Const	Version				"0.1.4 (2013-04-03)"

#Const	Description			"Keep the opponents away from your goal post and reach the goal on the other side of the map to score for your team."

/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/AFK.Script.txt" as AFK
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

/* SETTINGS */
// Match
#Setting	S_TimeLimit			240		as _("Time limit per round (seconds)")
#Setting	S_RoundToWin		5		as _("Rounds to win a map")
#Setting	S_RoundsGap			2		as _("Rounds gap to win a map")
#Setting	S_RoundsLimit		10		as _("Round limit per map (first team reaching X wins)")
// Gameplay
#Setting	S_CrazyModeActive	True	as _("Enable Crazy Mode")
#Setting	S_GrantArmorOnHit	True	as _("Grant armor on hits")

/* CONSTANTS */
#Const	C_ManageAFKPlayers		True	// Force afk players into spec
// UI
#Const	C_UIUpdateInterval		240		// Time between UI updates
#Const	C_HideStuffAtMapEnd		True	// Enable to hide mode widgets at map end
// Gameplay
#Const	C_CrazyModeArmorGain	9.0		// Armor gain while playing in crazy mode (Range: 0.0 - 10.0)
#Const	C_OvertimeTimeLimit		60		// Time limit of overtime
#Const	C_ArmorGrantedPerHit	60		// Armor granted per hit (100 = 1 point of armor) -> Only if S_GrantArmorOnHit!
#Const	C_TimePerArmorLose		3.0		// Seconds to lose 1 armor near own pole&spawn (camping prevention) (-1 to disable)
#Const	C_CapturePointsFactor	2		// Capture points: C_CapturePointsFactor * (2 + Number of opponents)
#Const	C_PointsForBackspace	-1		// Points granted if someone presses backspace
#Const	C_CamperDistance		25.0	// Distance for reducing armor and preventing backspace weapon change
#Const	C_PoleGaugeMax			1000	// Maximal value of poles
// Clublink constants
#Const	C_UsePlayerClublinks	True	// Enable use of player clublinks
#Const	C_NeutralEmblemUrl		""		// Neutral emblem URL

/* GLOBALES */
declare Real[Integer] G_ClanDistances;		// Reached distances of the team (overtime)
declare Ident[Integer] G_ClanSpawns;		// Ids of the spawns
declare Ident[Integer] G_ClanPoles;			// Ids of the goal posts
declare Integer G_LastAfkHandling;			// Time of last afk players handling
declare Integer G_LastUIUpdate;				// Time of last UI update
declare Boolean G_OvertimeActive;			// Whether overtime is active
// Cache
declare Boolean Cache_S_CrazyModeActive;	// Cache for S_CrazyModeActive
declare Boolean Cache_S_GrantArmorOnHit;	// Cache for S_GrantArmorOnHit

/*****************************************************
	EXTENSIONS
*****************************************************/
***StartServer***
***
log("Tjost.Script.txt loaded!");
log("Version: "^Version);

// Script variables
UseClans = True;
MB_UseSectionRound = True;

G_LastUIUpdate = 0;
G_LastAfkHandling = 0;

// Clublinks
MB_UsePlayerClublinks = C_UsePlayerClublinks;
MB_NeutralEmblemUrl = C_NeutralEmblemUrl;

// Cache
Cache_S_CrazyModeActive = S_CrazyModeActive;
Cache_S_GrantArmorOnHit = S_GrantArmorOnHit;

// UI
SM::SetupDefaultVisibility();
UIManager.UIAll.OverlayScoreSummary = True;
// Hide map warnings to suppress the "Pole captured by X" message
UIManager.UIAll.NoticesFilter_HideMapWarning = True;

// Rules layer
CreateRules();

// Team layer
declare TeamsLayer <=> UIManager.UILayerCreate();
Interface::SetLayerTeams(TeamsLayer);
UIManager.UIAll.UILayers.add(TeamsLayer);
// RangeLayer
declare MarkersLayer <=> UIManager.UILayerCreate();
MarkersLayer.Type = CUILayer::EUILayerType::Markers;
UIManager.UIAll.UILayers.add(MarkersLayer);
// Overtime Layer
declare OvertimeLayer <=> UIManager.UILayerCreate();
UIManager.UIAll.UILayers.add(OvertimeLayer);
***

***StartMap***
***
XmlRpc.SendCallback("beginMap", "");

UIManager.UIAll.SendNotice(
	"New Match", CUIConfig::ENoticeLevel::MatchInfo, 
	Null, CUIConfig::EAvatarVariant::Default, 
	CUIConfig::EUISound::StartMatch, 0);

// Prepare map
G_ClanSpawns.clear();
G_ClanPoles.clear();
foreach (Base in Bases) {
	Base.Clan = 0;
	Base.IsActive = True;
}
foreach (Spawn in BlockSpawns) {
	G_ClanSpawns[Spawn.Order] = Spawn.Id;
}
foreach (Pole in BlockPoles) {
	G_ClanPoles[Pole.Order] = Pole.Id;
	Pole.Gauge.Clan = 0;
	Pole.Gauge.Max = C_PoleGaugeMax;
}
UIManager.UIAll.Hud3dMarkers = GetHud3dMarkers();
MarkersLayer.ManialinkPage = GetMarkersLayerManialink();

// Prepare match
Score::MatchBegin();
Victory::MatchBegin();
for (Clan, 1, 2) {
	ClanScores[Clan] = 0;
}
Mode::Ladder_OpenMatch_All();

// UI
TeamsLayer.IsVisible = True;
MarkersLayer.IsVisible = True;
OvertimeLayer.IsVisible = True;
***

***StartRound***
***
XmlRpc.SendCallback("beginRound", "");

UIManager.UIAll.BigMessage = "";

Score::RoundBegin();
Victory::RoundBegin();

if (C_UsePlayerClublinks) {
	Clublink::DefineTeamsAuto();
}

// Prepare next round
PrepareNextRound();

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;

StartTime = Now + 3000;
UIManager.UIAll.CountdownEndTime = StartTime + S_TimeLimit * 1000;
EndTime = UIManager.UIAll.CountdownEndTime + C_OvertimeTimeLimit * 1000;
***

***PlayLoop***
***
// Check mode settings
CheckModeSettings();
// Handle afk players
if (C_ManageAFKPlayers && StartTime + 10000 < Now && G_LastAfkHandling + 10000 < Now) {
	G_LastAfkHandling = Now;
	AFK::ManageAFKPlayers();
}

// Perform actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			MySpawnPlayer(Player);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			if (Player.CurrentClan != Player.RequestedClan || Player.RequestsSpectate) {
				// Player wants to change team or spectate
				UnspawnPlayer(Player);
			} else {
				// Lose armor near the own pole
				if (S_CrazyModeActive && C_TimePerArmorLose > 0 && Player.StartTime + 5000 <= Now) {
					// Check distance to pole & spawn
					declare DistancePole = MathLib::Distance(Player.Position, BlockPoles[G_ClanPoles[3-Player.CurrentClan]].Position);
					declare DistanceSpawn = MathLib::Distance(Player.Position, BlockSpawns[G_ClanSpawns[Player.CurrentClan]].Position);
					if (DistancePole <= C_CamperDistance || DistanceSpawn <= C_CamperDistance) {
						// Check for lose tick
						declare LastArmorLose for Player = 0;
						if (LastArmorLose + C_TimePerArmorLose * 10 < Now) {
							LastArmorLose = Now;
							if (Player.Armor <= 100) {
								Player.Armor -= 100;
							} else {
								Player.Armor -= 1;
							}
						}
					}
				}
				// Check for captures
				if (Player.BlockPole != Null && Player.BlockPole.Gauge.Clan == Player.CurrentClan) {
					Player.BlockPole.Gauge.ValueReal = 1.0;
					Player.BlockPole.Gauge.Speed = C_PoleGaugeMax;
				}
				// Check for reached distance
				if (G_OvertimeActive) {
					declare DistancePole = Round(MathLib::Distance(Player.Position, BlockPoles[G_ClanPoles[Player.CurrentClan]].Position), 1);
					if (G_ClanDistances[Player.CurrentClan] < 0.0 || DistancePole < G_ClanDistances[Player.CurrentClan]) {
						G_ClanDistances[Player.CurrentClan] = DistancePole;
					}
				}
			}
		}
	}
}

// Handle events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnCapture: {
			// Goal captured!
			Victory::SetRoundWinnerIfNoWinner(Event.BlockPole.Gauge.Clan);
			// Grant points for capture
			declare CapturerId = NullId;
			foreach (PlayerId in Event.BlockPole.Sector.PlayersIds) {
				if (Players.existskey(PlayerId) && Players[PlayerId].CurrentClan == Event.BlockPole.Gauge.Clan) {
					Score::AddPoints(Players[PlayerId], (2 + ClansNbPlayers[3-Event.BlockPole.Gauge.Clan]) * C_CapturePointsFactor);
					CapturerId = PlayerId;
					if (!Players[PlayerId].IsFakePlayer) {
						XmlRpc.SendCallback("poleCapture", Players[PlayerId].Login);
					}
				}
			}
			if (CapturerId != NullId && Teams.existskey(Players[CapturerId].CurrentClan-1)) {
				UIManager.UIAll.SendNotice(
					"""$<{{{Players[CapturerId].Name}}}$> captured the $<{{{Teams[Players[CapturerId].CurrentClan-1].ColorText}}}Goal$>!""", CUIConfig::ENoticeLevel::MatchInfo, 
					Null, CUIConfig::EAvatarVariant::Default, 
					CUIConfig::EUISound::Capture, 0);
				Discard(Event);
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			// Grant points because of backspace
			Score::AddPoints(Event.Shooter, C_PointsForBackspace);
			// Respawn player with or without (?) new random weapon
			declare DistanceSpawn = MathLib::Distance(Event.Player.Position, BlockSpawns[G_ClanSpawns[Event.Player.CurrentClan]].Position);
			MySpawnPlayer(Event.Player, (DistanceSpawn > C_CamperDistance));
			if (!Event.Player.IsFakePlayer) {
				XmlRpc.SendCallback("playerRespawn", Event.Player.Login);
			}
			Discard(Event);
		}
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Shooter == Null) {
				// AFK check with last death position
				if (C_ManageAFKPlayers) {
					declare Vec3 LastDeathPosition for Event.Victim;
					if (LastDeathPosition == Event.Victim.Position) {
						// Died on same spot - Afk! - Switch to spec
						declare UI <=> UIManager.GetUI(Event.Victim);
						if (UI != Null) {
							UI.SendNotice(
								"You are inactive! Switching to spec...", CUIConfig::ENoticeLevel::Default, 
								Null, CUIConfig::EAvatarVariant::Default, 
								CUIConfig::EUISound::Silence, 0);
						}
						This.Users_RequestSwitchToSpectator(Event.Victim.User);
					} else {
						// Not afk - Save position for next check
						LastDeathPosition = Event.Victim.Position;
					}
				}
			}
						
			if (!Event.Victim.IsFakePlayer) {
				if (Event.Shooter != Null && !Event.Shooter.IsFakePlayer) {
					XmlRpc.SendCallback("playerKill", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";");
				}
				XmlRpc.SendCallback("playerDeath", Event.Victim.Login);
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnHit: {
			if (Event.Shooter == Null || Event.Victim == Null ) {
				// Discard buggy event
				Discard(Event);
			} else {
				// Reduce damage to 1
				Event.Damage = 100;
				if (Event.Shooter == Event.Victim && !S_CrazyModeActive) {
					// Discard self hit
					Discard(Event);
				} else {
					// Kill victim if it hasn't at least 2 armor
					if (Event.Victim.Armor < 200) {
						Event.Damage = Event.Victim.Armor;
					}
					// Grant points
					declare Points = 1;
					// Negative points for team hits
					if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
						Points *= -1;
					}
					Event.ShooterPoints = Points;
					// Grant armor for hits
					if (S_GrantArmorOnHit && Event.Shooter != Event.Victim) {
						Event.Shooter.Armor += C_ArmorGrantedPerHit;
					}
					Score::AddPoints(Event.Shooter, Points);
					if (!Event.Shooter.IsFakePlayer && !Event.Victim.IsFakePlayer) {
						XmlRpc.SendCallback("playerHit", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";"^Points);
					}
					PassOn(Event);
				}
			}
		}
		default: {
			PassOn(Event);
		}
	}
}

// UI updates
if (G_LastUIUpdate + C_UIUpdateInterval < Now) {
	G_LastUIUpdate = Now;
	
	// Score summary
	UpdateScoreSummary();
	
	// Range display update
	if (G_OvertimeActive) {
		OvertimeLayer.ManialinkPage = """
			<label posn="0 66 40" text="Overtime!" textprefix="$s$o" textsize="3" halign="center" valign="center2"/>
			<label posn="0 60 30" text=":Distances:" textprefix="$s" textsize="2" halign="center" valign="center2"/>
			<label posn="-11 60 30" text="{{{G_ClanDistances[1]}}}m" textprefix="$s{{{Teams[0].ColorText}}}" textsize="2" halign="right" valign="center2"/>
			<label posn="11 60 30" text="{{{G_ClanDistances[2]}}}m" textprefix="$s{{{Teams[1].ColorText}}}" textsize="2" halign="left" valign="center2"/>
			""";
	} else {
		OvertimeLayer.ManialinkPage = "";
	}
}

// Round end conditions
if (Now >= UIManager.UIAll.CountdownEndTime) {
	if (ClansNbPlayers[1] <= 0 || ClansNbPlayers[2] <= 0) {
		// Insufficient number of players
		Victory::SetRoundDrawIfNoWinner();
	} else {
		// Regular time is up -> Begin overtime
		G_OvertimeActive = True;
		UIManager.UIAll.CountdownEndTime = -1;
		
		if (Now >= EndTime) {
			// Round time is up -> Evaluate reached distances
			for (Clan, 1, 2) {
				if (G_ClanDistances[Clan] > 0.0 && (G_ClanDistances[Clan] < G_ClanDistances[3-Clan] || G_ClanDistances[3-Clan] < 0.0)) {
					// Team got closer than the other team
					Victory::SetRoundWinnerIfNoWinner(Clan);
					break;
				}
			}
			Victory::SetRoundDrawIfNoWinner();
		}
	}
}
if (!Victory::NoRoundWinner()) {
	MB_StopRound = True;
}
***

***EndRound***
***
XmlRpc.SendCallback("endRound", GetRankings());

SM::UnspawnAllPlayers();
StartTime = -1;
UIManager.UIAll.CountdownEndTime = -1;
EndTime = -1;

if (Victory::IsRoundDraw()) {
	UIManager.UIAll.BigMessage = "Round Draw!";
} else {
	for (Clan, 1, 2) {
		if (Victory::IsRoundWinner(Clan)) {
			UIManager.UIAll.BigMessage = """$<{{{Teams[Clan-1].ColorizedName}}}$> wins the round!""";
			ClanScores[Clan] += 1;
			break;
		}
	}
}

UpdateScoreSummary();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

MB_Sleep(2000);

Score::RoundEnd();
Victory::RoundEnd();

// Match end conditions
Victory::SetMatchWinnerFromScore(S_RoundToWin, S_RoundsGap, S_RoundsLimit);
if (!Victory::NoMatchWinner()) {
	MB_StopMap = True;
	
	for (Clan, 1, 2) {
		if (Victory::IsMatchWinner(Clan)) {
			UIManager.UIAll.BigMessage = """$<{{{Teams[Clan-1].ColorizedName}}}$> wins the map!""";
			break;
		}
	}
}

MB_Sleep(1000);
***

***EndMap***
***
XmlRpc.SendCallback("endMap", GetRankings());

Score::MatchEnd();
Victory::MatchEnd();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;

// UI
if (C_HideStuffAtMapEnd) {
	TeamsLayer.IsVisible = False;
	MarkersLayer.IsVisible = False;
	OvertimeLayer.IsVisible = False;
}

MB_Sleep(3500);

Mode::Ladder_CloseMatch();
Clublink::DefineTeamsDefault();
***

***EndServer***
***
// Clean up
UIManager.UILayerDestroyAll();
***

// Round a given real to fit a given number of decimal places
Real Round(Real _Number, Integer _Places) {
	// Calculate factor
	declare Factor = 10.0;
	for (Index, 2, _Places) {
		Factor *= Factor;
	}
	// Round number
	return MathLib::NearestInteger(_Number * Factor) / Factor;
}

// Prepare map and blocks for the next round
Void PrepareNextRound() {
	// VALUES
	G_ClanDistances[1] = -1.0;
	G_ClanDistances[2] = -1.0;
	G_OvertimeActive = False;

	// POLES
	// Switch sides
	declare Temp = G_ClanPoles[1];
	G_ClanPoles[1] = G_ClanPoles[2];
	G_ClanPoles[2] = Temp;
	// Assign teams & values
	foreach (Clan => PoleId in G_ClanPoles) {
		BlockPoles[PoleId].Base.Clan = Clan;
		BlockPoles[PoleId].Gauge.Clan = Clan;
		BlockPoles[PoleId].Gauge.Speed = 0;
		BlockPoles[PoleId].Gauge.Value = C_PoleGaugeMax-1;
	}
	
	// SPAWNS
	// Switch sides
	Temp = G_ClanSpawns[1];
	G_ClanSpawns[1] = G_ClanSpawns[2];
	G_ClanSpawns[2] = Temp;
	// Assign teams
	foreach (Clan => SpawnId in G_ClanSpawns) {
		BlockSpawns[SpawnId].Base.Clan = Clan;
	}
}

// Spawn the given player and perform necessary actions
Void MySpawnPlayer(CSmPlayer _Player, Boolean _RandomWeapon) {
	// Unspawn player
	This.UnspawnPlayer(_Player);

	if (!_Player.RequestsSpectate) {
		// Set random weapon
		if (_RandomWeapon) {
			declare Weapon = MathLib::Rand(0, 2);
			switch (Weapon) {
				case 0: {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
				}
				case 1: {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, True);
				}
				case 2: {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, True);
				}
			}
		}
		
		// Set player values
		_Player.ArmorGain = 0;
		if (S_CrazyModeActive) {
			// Crazy Mode
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 10);
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 10);
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 10);
			
			_Player.AmmoGain = C_CrazyModeArmorGain;
			_Player.ArmorMax = 1000;
		} else {
			// Normal Mode
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 1);
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
			
			_Player.AmmoGain = 1.0;
			_Player.ArmorMax = 200;
		}
		
		// Spawn player
		SM::SpawnPlayer(_Player, _Player.RequestedClan, BlockSpawns[G_ClanSpawns[_Player.RequestedClan]], Now);
	}
}

Void MySpawnPlayer(CSmPlayer _Player) {
	MySpawnPlayer(_Player, True);
}

// Create rules layer shown in the spawn
Void CreateRules() {
	SpawnScreen::DestroyRules();
	
	declare Rules = """
$<$0f0Keep$> the $<$0f0opponents away$> from your goal post.

$<$0f0Reach$> the $<$0f0goal$> on the other side of the map $<$0f0to score$> for your team.

If neither team manages to score after $<$f80{{{S_TimeLimit}}}$> seconds, $<$f00Overtime$> kicks in! Then you will have $<$f80{{{C_OvertimeTimeLimit}}}$> seconds to get the closest to your teams goal post.
""";
	if (S_GrantArmorOnHit) {
		Rules ^= """
Camping your goal post the whole time will lead you to lose armor constantly.
You will get $<$f80{{{C_ArmorGrantedPerHit/100.0}}}$> armor granted for each shot you land on any player!
""";
	}
	if (S_CrazyModeActive) {
		Rules ^= """
		
- $<$f80Crazy Mode$> Active: 10 Armor + 10 Shots + Fast Reload!""";
	}
	
	SpawnScreen::CreateRules("Tjost", Rules, False);
	SpawnScreen::AttachRules();
}

// Check for changed script settings
Void CheckModeSettings() {
	declare UpdateRules = False;
	
	// Crazy mode
	if (Cache_S_CrazyModeActive != S_CrazyModeActive) {
		Cache_S_CrazyModeActive = S_CrazyModeActive;
		// Announce change
		if (S_CrazyModeActive) {
			UIManager.UIAll.SendChat("$<$f80Crazy Mode$> is now $<$0f0actived$>!");
		} else {
			UIManager.UIAll.SendChat("$<$f80Crazy Mode$> is now $<$f00deactived$>!");
		}
		UpdateRules = True;
	}
	
	// Grant armor on hits
	if (Cache_S_GrantArmorOnHit != S_GrantArmorOnHit) {
		Cache_S_GrantArmorOnHit = S_GrantArmorOnHit;
		UpdateRules = True;
	}
	
	if (UpdateRules) {
		// Update rules
		CreateRules();
	}
}

// Update the score summary at the top
Void UpdateScoreSummary() {
	declare PlayerClan1Id = NullId;
	declare PlayerClan2Id = NullId;
	foreach (Player in Players) {
		if (Player.CurrentClan == 1 && (PlayerClan1Id == NullId || Player.User.ClubLink != "" && Players[PlayerClan1Id].User.ClubLink == "")) {
			PlayerClan1Id = Player.Id;
		} else {
			if (Player.CurrentClan == 2 && (PlayerClan2Id == NullId || Player.User.ClubLink != "" && Players[PlayerClan2Id].User.ClubLink == "")) {
				PlayerClan2Id = Player.Id;
			} else {
				if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
					break;
				}
			}
		}
	}
	if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
		UIManager.UIAll.OverlayScoreSummary = True;
		UIManager.UIAll.ScoreSummary_Player1 = PlayerClan1Id;
		UIManager.UIAll.ScoreSummary_Points1 = ClanScores[1];
		UIManager.UIAll.ScoreSummary_Player2 = PlayerClan2Id;
		UIManager.UIAll.ScoreSummary_Points2 = ClanScores[2];
	} else {
		UIManager.UIAll.OverlayScoreSummary = False;
	}
}

// Get Hud3dMarkers
Text GetHud3dMarkers() {
	declare Markers = "";
	foreach (Pole in BlockPoles) {
		if (Pole.Order == 1 || Pole.Order == 2) {
			Markers ^= """<marker pos="{{{Pole.Position[0]}}} {{{Pole.Position[1]}}} {{{Pole.Position[2]}}}" manialinkframeid="Frame_PoleMarker{{{Pole.Order}}}" box="0 6 0"/>""";
		}
	}
	return Markers;
}

// Get manialink for MarkersLayer
Text GetMarkersLayerManialink() {
	declare Manialink = """
		<script><!--
			main() {
				declare Label_PoleMarker1 <=> (Page.GetFirstChild("Label_PoleMarker1") as CMlLabel);
				declare Label_PoleMarker2 <=> (Page.GetFirstChild("Label_PoleMarker2") as CMlLabel);
				
				declare Ident[Integer] PoleIds;
				foreach (Pole in BlockPoles) {
					if (Pole.Order == 1 || Pole.Order == 2) {
						PoleIds[Pole.Order] = Pole.Id;
					}
				}
				
				declare LastUIUpdate = 0;
				
				while (True) {
					yield;
					
					if (LastUIUpdate + 200 < Now) {
						LastUIUpdate = Now;
						
						declare ThisPlayer <=> InputPlayer;
						if (GUIPlayer != Null) {
							//DISABLED BECAUSE OF A BUG BY GUIYPLAYER
							//ThisPlayer <=> GUIPlayer;
						}
						
						if (ThisPlayer != Null) {
							// Update pole markers
							foreach (Order => Id in PoleIds) {
								declare Tag = "";
								declare PoleClan = BlockPoles[Id].Gauge.Clan;
								if (Teams.existskey(PoleClan-1)) {
									if (IsSpectatorMode) {
										Tag = Teams[PoleClan-1].ColorizedName;
									} else {
										Tag = Teams[PoleClan-1].ColorText;
										if (BlockPoles[Id].Gauge.Clan == ThisPlayer.CurrentClan) {
											Tag ^= "Attack";
										} else {
											Tag ^= "Defend";
										}
									}
								}
								switch (Order) {
									case 1: {
										Label_PoleMarker1.Value = Tag;
									}
									case 2: {
										Label_PoleMarker2.Value = Tag;
									}
								}
							}
						}
					}
				}
			}
		--></script>
		<frame id="Frame_PoleMarker1" hidden="1">
			<label id="Label_PoleMarker1" posn="0 4" textsize="2" scale="0.8" halign="center" valign="center2"/>
			<quad posn="0 4" sizen="12 4" halign="center" valign="center" style="BgsPlayerCard" substyle="BgMediaTracker"/>
		</frame>
		<frame id="Frame_PoleMarker2" hidden="1">
			<label id="Label_PoleMarker2" posn="0 4" textsize="2" scale="0.8" halign="center" valign="center2"/>
			<quad posn="0 4" sizen="12 4" halign="center" valign="center" style="BgsPlayerCard" substyle="BgMediaTracker"/>
		</frame>
		""";
	return Manialink;
}

// Get current rankings for xml rpc callbacks
Text GetRankings() {
	declare Rankings = "";
	foreach (Score in Scores) {
		Rankings ^= Score.User.Login^":"^Score.Points^";";
	}
	return Rankings;
}
