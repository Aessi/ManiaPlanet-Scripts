/****************************************
*	Tjost Game Mode						*
*	Author:		steeffeen				*
*	Contact:	schteffens@gmail.com	*
****************************************/

/*
TODO:
*/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"TjostArena,SpeedBallArena"
#Const	Version				"0.1.2 (2013-03-31)"

#Const	Description			"Keep the opponents away from your goal post and reach the goal on the other side of the map to score for your team."

/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/AFK.Script.txt" as AFK
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

/* SETTINGS */
// Match
#Setting	S_TimeLimit			240		as _("Time limit per round (seconds)")
#Setting	S_RoundToWin		5		as _("Rounds to win a map")
#Setting	S_RoundsGap			2		as _("Rounds gap to win a map")
#Setting	S_RoundsLimit		10		as _("Round limit per map (first team reaching X wins)")
// Gameplay
#Setting	S_CrazyModeActive	True	as _("Enable Crazy Mode")
#Setting	S_GrantArmorOnHit	True	as _("Grant armor on hits")

/* CONSTANTS */
#Const	C_ManageAFKPlayers		True	// Force afk players into spec
// UI
#Const	C_UIUpdateInterval		240		// Time between UI updates
#Const	C_HideStuffAtMapEnd		True	// Enable to hide mode widgets at map end
// Gameplay
#Const	C_ArmorGrantedPerHit	60		// Armor granted per hit (100 = 1 point of armor) -> Only if S_GrantArmorOnHit!
#Const	C_TimePerArmorLose		3		// Seconds to lose 1 armor near own pole&spawn (camping prevention) (-1 to disable)
#Const	C_CapturePointsFactor	2		// Capture points: C_CapturePointsFactor * (2 + Number of opponents)
#Const	C_PointsForBackspace	-1		// Points granted if someone presses backspace
#Const	C_CamperDistance		20.0	// Distance for reducing armor and preventing backspace weapon change
// Clublink constants
#Const	C_UsePlayerClublinks	True	// Enable use of player clublinks
#Const	C_NeutralEmblemUrl		""		// Neutral emblem URL

/* GLOBALES */
declare Ident[Integer] G_ClanSpawns;		// Ids of the spawns
declare Ident[Integer] G_ClanPoles;			// Ids of the goal posts
declare Integer G_LastAfkHandling;			// Time of last afk players handling
declare Integer G_LastUIUpdate;				// Time of last UI update
// Cache
declare Boolean Cache_S_CrazyModeActive;	// Cache for S_CrazyModeActive
declare Boolean Cache_S_GrantArmorOnHit;	// Cache for S_GrantArmorOnHit

/*****************************************************
	EXTENSIONS
*****************************************************/
***StartServer***
***
log("Tjost.Script.txt loaded!");
log("Version: "^Version);

// Script variables
UseClans = True;
MB_UseSectionRound = True;

G_LastUIUpdate = 0;
G_LastAfkHandling = 0;

// Clublinks
MB_UsePlayerClublinks = C_UsePlayerClublinks;
MB_NeutralEmblemUrl = C_NeutralEmblemUrl;

// Cache
Cache_S_CrazyModeActive = S_CrazyModeActive;
Cache_S_GrantArmorOnHit = S_GrantArmorOnHit;

// UI
SM::SetupDefaultVisibility();

// Rules layer
CreateRules();

// Team layer
declare TeamsLayer <=> UIManager.UILayerCreate();
Interface::SetLayerTeams(TeamsLayer);
UIManager.UIAll.UILayers.add(TeamsLayer);
***

***StartMap***
***
XmlRpc.SendCallback("beginMap", "");

// Prepare map
G_ClanSpawns.clear();
G_ClanPoles.clear();
foreach (Base in Bases) {
	Base.Clan = 0;
	Base.IsActive = True;
}
foreach (Spawn in BlockSpawns) {
	G_ClanSpawns[Spawn.Order] = Spawn.Id;
}
foreach (Pole in BlockPoles) {
	G_ClanPoles[Pole.Order] = Pole.Id;
	Pole.Gauge.Clan = 0;
	Pole.Gauge.Max = 1;
}

// Prepare match
Score::MatchBegin();
Victory::MatchBegin();
for (Clan, 1, 2) {
	ClanScores[Clan] = 0;
}
Mode::Ladder_OpenMatch_All();

// UI
TeamsLayer.IsVisible = True;
***

***StartRound***
***
XmlRpc.SendCallback("beginRound", "");

UIManager.UIAll.BigMessage = "";

Score::RoundBegin();
Victory::RoundBegin();

if (C_UsePlayerClublinks) {
	Clublink::DefineTeamsAuto();
}

// Prepare next round
PrepareNextRound();

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;

StartTime = Now + 3000;
EndTime = StartTime + S_TimeLimit * 1000;
***

***PlayLoop***
***
// Check mode settings
CheckModeSettings();
// Handle afk players
if (C_ManageAFKPlayers && StartTime + 10000 < Now && G_LastAfkHandling + 30000 < Now) {
	G_LastAfkHandling = Now;
	AFK::ManageAFKPlayers();
}

// Perform actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			MySpawnPlayer(Player);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			if (Player.CurrentClan != Player.RequestedClan || Player.RequestsSpectate) {
				// Player wants to change team or spectate
				UnspawnPlayer(Player);
			} else {
				// Lose armor near the own pole
				if (S_CrazyModeActive && C_TimePerArmorLose > 0 && Player.StartTime + 5000 <= Now) {
					// Check distance to pole & spawn
					declare DistancePole = MathLib::Distance(Player.Position, BlockPoles[G_ClanPoles[3-Player.CurrentClan]].Position);
					declare DistanceSpawn = MathLib::Distance(Player.Position, BlockSpawns[G_ClanSpawns[Player.CurrentClan]].Position);
					if (DistancePole <= C_CamperDistance || DistanceSpawn <= C_CamperDistance) {
						// Check for lose tick
						declare LastArmorLose for Player = 0;
						if (LastArmorLose + C_TimePerArmorLose * 10 < Now) {
							LastArmorLose = Now;
							Player.Armor -= 1;
						}
					}
				}
				// Check for captures
				if (Player.BlockPole != Null && Player.BlockPole.Gauge.Clan == Player.CurrentClan) {
					Player.BlockPole.Gauge.ValueReal = 1.0;
					Player.BlockPole.Gauge.Speed = 1;
				}
			}
		}
	}
}

// Handle events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnCapture: {
			// Goal captured!
			Victory::SetRoundWinnerIfNoWinner(Event.BlockPole.Gauge.Clan);
			// Grant points for capture
			foreach (PlayerId in Event.BlockPole.Sector.PlayersIds) {
				if (Players.existskey(PlayerId) && Players[PlayerId].CurrentClan == Event.BlockPole.Gauge.Clan) {
					Score::AddPoints(Players[PlayerId], (2 + ClansNbPlayers[3-Event.BlockPole.Gauge.Clan]) * C_CapturePointsFactor);
					if (!Players[PlayerId].IsFakePlayer) {
						XmlRpc.SendCallback("poleCapture", Players[PlayerId].Login);
					}
				}
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			// Grant points because of backspace
			Score::AddPoints(Event.Shooter, C_PointsForBackspace);
			// Respawn player with or without (?) new random weapon
			declare DistanceSpawn = MathLib::Distance(Event.Player.Position, BlockSpawns[G_ClanSpawns[Event.Player.CurrentClan]].Position);
			MySpawnPlayer(Event.Player, (DistanceSpawn > C_CamperDistance));
			if (!Event.Player.IsFakePlayer) {
				XmlRpc.SendCallback("playerRespawn", Event.Player.Login);
			}
			Discard(Event);
		}
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (!Event.Victim.IsFakePlayer) {
				if (Event.Shooter != Null && !Event.Shooter.IsFakePlayer) {
					XmlRpc.SendCallback("playerKill", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";");
				}
				XmlRpc.SendCallback("playerDeath", Event.Victim.Login);
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnHit: {
			if (Event.Shooter == Null || Event.Victim == Null ) {
				// Discard buggy event
				Discard(Event);
			} else {
				// Reduce damage to 1
				Event.Damage = 100;
				if (Event.Shooter == Event.Victim && !S_CrazyModeActive) {
					// Discard self hit
					Discard(Event);
				} else {
					// Kill if victim hasn't at least 2 armor
					if (Event.Victim.Armor < 200) {
						Event.Damage = Event.Victim.Armor;
					}
					// Grant points
					declare Points = 1;
					// Negative points for team hits
					if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
						Points *= -1;
						// Doubled points for self hits
						if (Event.Shooter == Event.Victim) {
							Points *= 2;
						}
					}
					if (Event.Shooter != Event.Victim) {
						// Non-self hit
						Event.ShooterPoints = Points;
						// Grant armor for hits
						if (S_GrantArmorOnHit) {
							Event.Shooter.Armor += C_ArmorGrantedPerHit;
						}
					}
					Score::AddPoints(Event.Shooter, Points);
					if (!Event.Shooter.IsFakePlayer && !Event.Victim.IsFakePlayer) {
						XmlRpc.SendCallback("playerHit", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";"^Points);
					}
					PassOn(Event);
				}
			}
		}
		default: {
			PassOn(Event);
		}
	}
}

// UI updates
if (G_LastUIUpdate + C_UIUpdateInterval < Now) {
	G_LastUIUpdate = Now;
	
	// Score summary
	UpdateScoreSummary();
}

// Round end conditions
if (Now >= EndTime) {
	// Time is up -> Round Draw
	Victory::SetRoundDrawIfNoWinner();
}
if (!Victory::NoRoundWinner()) {
	MB_StopRound = True;
}
***

***EndRound***
***
XmlRpc.SendCallback("endRound", GetRankings());

StartTime = -1;
EndTime = -1;

for (Clan, 1, 2) {
	if (Victory::IsRoundWinner(Clan)) {
		UIManager.UIAll.BigMessage = """$<{{{Teams[Clan-1].ColorizedName}}}$> wins the round!""";
		ClanScores[Clan] += 1;
		break;
	}
}
UpdateScoreSummary();

MB_Sleep(2000);

Score::RoundEnd();
Victory::RoundEnd();

// Match end conditions
Victory::SetMatchWinnerFromScore(S_RoundToWin, S_RoundsGap, S_RoundsLimit);
if (!Victory::NoMatchWinner()) {
	MB_StopMap = True;
	
	for (Clan, 1, 2) {
		if (Victory::IsMatchWinner(Clan)) {
			UIManager.UIAll.BigMessage = """$<{{{Teams[Clan-1].ColorizedName}}}$> wins the map!""";
			break;
		}
	}
}

SM::UnspawnAllPlayers();

MB_Sleep(3000);
***

***EndMap***
***
XmlRpc.SendCallback("endMap", GetRankings());

Score::MatchEnd();
Victory::MatchEnd();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;

// UI
if (C_HideStuffAtMapEnd) {
	TeamsLayer.IsVisible = False;
}

MB_Sleep(1500);

Mode::Ladder_CloseMatch();
Clublink::DefineTeamsDefault();
***

***EndServer***
***
// Clean up
UIManager.UILayerDestroyAll();
***

// Prepare map and blocks for the next round
Void PrepareNextRound() {
	// POLES
	// Switch sides
	declare Temp = G_ClanPoles[1];
	G_ClanPoles[1] = G_ClanPoles[2];
	G_ClanPoles[2] = Temp;
	// Assign teams & values
	foreach (Clan => PoleId in G_ClanPoles) {
		BlockPoles[PoleId].Base.Clan = Clan;
		BlockPoles[PoleId].Gauge.Clan = Clan;
		BlockPoles[PoleId].Gauge.Speed = 0;
		BlockPoles[PoleId].Gauge.Value = 0;
	}
	
	// SPAWNS
	// Switch sides
	Temp = G_ClanSpawns[1];
	G_ClanSpawns[1] = G_ClanSpawns[2];
	G_ClanSpawns[2] = Temp;
	// Assign teams
	foreach (Clan => SpawnId in G_ClanSpawns) {
		BlockSpawns[SpawnId].Base.Clan = Clan;
	}
}

// Spawn the given player and perform necessary actions
Void MySpawnPlayer(CSmPlayer _Player, Boolean _RandomWeapon) {
	// Unspawn player
	This.UnspawnPlayer(_Player);

	if (!_Player.RequestsSpectate) {
		// Set random weapon
		if (_RandomWeapon) {
			declare Weapon = MathLib::Rand(0, 2);
			switch (Weapon) {
				case 0: {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
				}
				case 1: {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, True);
				}
				case 2: {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, True);
				}
			}
		}
		
		// Set player values
		_Player.ArmorGain = 0;
		if (S_CrazyModeActive) {
			// Crazy Mode
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 10);
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 10);
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 10);
			
			_Player.AmmoGain = 10.0;
			_Player.ArmorMax = 1000;
		} else {
			// Normal Mode
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 1);
			This.SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
			
			_Player.AmmoGain = 1.0;
			_Player.ArmorMax = 200;
		}
		
		// Spawn player
		SM::SpawnPlayer(_Player, _Player.RequestedClan, BlockSpawns[G_ClanSpawns[_Player.RequestedClan]], Now);
	}
}

Void MySpawnPlayer(CSmPlayer _Player) {
	MySpawnPlayer(_Player, True);
}

// Create rules layer shown in the spawn
Void CreateRules() {
	SpawnScreen::DestroyRules();
	
	declare Rules = """
$<$0f0Keep$> the $<$0f0opponents away$> from your goal post.

$<$0f0Reach$> the $<$0f0goal$> on the other side of the map $<$0f0to score$> for your team.
""";
	if (S_GrantArmorOnHit) {
		Rules ^= """
You will get {{{C_ArmorGrantedPerHit/100.0}}} armor reloaded for each shot you land on any player!
""";
	}
	if (S_CrazyModeActive) {
		Rules ^= """
		
- $<$f80Crazy Mode$> Active: 10 Armor + 10 Shots + Fast Reload!""";
	}
	
	SpawnScreen::CreateRules("Tjost", Rules, False);
	SpawnScreen::AttachRules();
}

// Check for changed script settings
Void CheckModeSettings() {
	declare UpdateRules = False;
	
	// Crazy mode
	if (Cache_S_CrazyModeActive != S_CrazyModeActive) {
		Cache_S_CrazyModeActive = S_CrazyModeActive;
		// Announce change
		if (S_CrazyModeActive) {
			UIManager.UIAll.SendChat("$<$f80Crazy Mode$> is now $<$0f0actived$>!");
		} else {
			UIManager.UIAll.SendChat("$<$f80Crazy Mode$> is now $<$f00deactived$>!");
		}
		UpdateRules = True;
	}
	
	// Grant armor on hits
	if (Cache_S_GrantArmorOnHit != S_GrantArmorOnHit) {
		Cache_S_GrantArmorOnHit = S_GrantArmorOnHit;
		UpdateRules = True;
	}
	
	if (UpdateRules) {
		// Update rules
		CreateRules();
	}
}

// Update the score summary at the top
Void UpdateScoreSummary() {
	declare PlayerClan1Id = NullId;
	declare PlayerClan2Id = NullId;
	foreach (Player in Players) {
		if (PlayerClan1Id == NullId && Player.CurrentClan == 1) {
			PlayerClan1Id = Player.Id;
		} else {
			if (PlayerClan2Id == NullId && Player.CurrentClan == 2) {
				PlayerClan2Id = Player.Id;
			} else {
				if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
					break;
				}
			}
		}
	}
	if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
		UIManager.UIAll.OverlayScoreSummary = True;
		UIManager.UIAll.ScoreSummary_Player1 = PlayerClan1Id;
		UIManager.UIAll.ScoreSummary_Points1 = ClanScores[Players[PlayerClan1Id].CurrentClan];
		UIManager.UIAll.ScoreSummary_Player2 = PlayerClan2Id;
		UIManager.UIAll.ScoreSummary_Points2 = ClanScores[Players[PlayerClan2Id].CurrentClan];
	} else {
		UIManager.UIAll.OverlayScoreSummary = False;
	}
}

// Get current rankings for xml rpc callbacks
Text GetRankings() {
	declare Rankings = "";
	foreach (Score in Scores) {
		Rankings ^= Score.User.Login^":"^Score.Points^";";
	}
	return Rankings;
}
