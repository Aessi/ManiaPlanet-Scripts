/* -------------------- */
//	1337 Game Mode		//
//	(Custom Elite)		//
//	Made by steeffeen	//
/* -------------------- */

/* TODO:
- ton wenn jemd drankommt
- callback wenn jemd spec is / back ist
- teams layer l√§sst sich net ausblenden
- teamslayer at top
- won attack rounds
- anzeige defender live count
- UI TAB geht generell net ausblenden wenn man spectator is
*/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"EliteArena"
#Const	Version				"0.2 (2013-02-18)"
#Const	Description			"$nPractice your Elite skills with fewer players"

/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/Rules.Script.txt" as Rules
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/WarmUpSimple.Script.txt" as WarmUp

/* SETTINGS */
// Round settings
#Setting	S_PointsLimit			75		as _("Points limit to win a map")
#Setting	S_TimeLimit				45		as _("Time limit per round (seconds)")
#Setting	S_TimeLimitCapturing	15		as _("Time limit to capture the goal (seconds)")
// Gameplay settings
#Setting	S_CaptureTime			1.5		as _("Time needed to capture goals (seconds)")
#Setting	S_LaserAttackers		True	as _("Attackers get lasers")
#Setting	S_FriendlyFire			False	as _("Friendly Fire (Damage team mates)")
#Setting	S_Beta2Gameplay			True	as _("Use Beta2 Gameplay")
#Setting	S_MaxDefenderCount		3		as _("Maximal count of defenders")
// WarmUp settings
#Setting	S_UseWarmUp				True	as _("Use warmup before each map")

/* CONSTANTS */
#Const	C_LogEnabled				False		// Enable/disable logging
// UI constants
#Const	C_UITickInterval			250			// Interval of UI refreshes
#Const	C_NearMissDist				1.0			// Max distance to show the near-miss message
// Gameplay constants
#Const	C_AttackerClan				0			// 1: Blue, 2: Red, else random
#Const	C_AttackerAmmoGain			1.0			// Attacker ammunition gain rate
#Const	C_DefenderAmmoGain			1.0			// Defender ammunition gain rate
#Const	C_UseLaserVsBullets			True		// Whether lasers can destroy rockets
#Const	C_AttackRoundBonus			6			// Bonus points for a won attack round
#Const	C_DefendRoundBonus			3			// Bonus points for each defending player if they win the defense round
// WarmUp constants
#Const	C_WarmUpDuration			90			// WarmUp duration
// Bot count
#Const	C_NbBots					4			// Number of bots

/* GLOBALES */
declare Integer G_LastUIUpdate;				// Time of last UI update
declare Integer G_LastBigMessage;			// Time of last big message
declare Integer G_LastStatusMessage;		// Time of last status message
declare Ident G_AttackerId;					// Id of currently attacking player
declare Integer G_AttackingClan;			// Currently attacking clan
declare Ident[] G_DefendingPlayerIds;		// IDs of currently defending players
declare Boolean G_CapturingPossible;		// Whether it's possible to capture the goal
declare Integer G_CountdownEndTime;			// Countdown end time
declare Integer[Ident] G_AttackRounds;		// Attack rounds per player
declare Integer[Ident] G_DefendRounds;		// Defend rounds per player
declare Integer[Ident] G_LastAttackTime;	// Time when the player attacked the last time
declare Integer G_MaxDefenderCount;			// Maximal count of defenders
declare CUILayer G_LayerScoresTableExtension;	// Layer for ScoresTableExtension
// Setting caches
declare Integer Cache_S_PointsLimit;

/*****************************************************
	EXTENSIONS
*****************************************************/
***StartServer***
***
log("1337.Script.txt loaded!");
log("Version: "^Version);

MB_UseLogging = C_LogEnabled;

// Game settings
UseClans = True;
UseForcedClans = True;
UseLaserVsBullets = C_UseLaserVsBullets;

// Init variables
MB_UseSectionRound = True;

// Rules
declare ModeName = "1337";
declare ModeRules = "$<$1f1Elite$> game mode for $<$4f4training$> matches.";
Rules::Create(ModeName, ModeRules);

declare LayerTeams <=> UIManager.UILayerCreate();
LayerTeams.AttachId = "LayerTeams";
declare LayerPosition <=> UIManager.UILayerCreate();
LayerPosition.AttachId = "LayerPosition";
G_LayerScoresTableExtension <=> UIManager.UILayerCreate();
G_LayerScoresTableExtension.AttachId = "LayerScoreBoardExtension";
G_LayerScoresTableExtension.Type = CUILayer::EUILayerType::ScoresTable;
***

***StartMap***
***
XmlRpc.SendCallback("beginMap", "");

Mode::Ladder_OpenMatch_All();

// UI
UIManager.ResetAll();
UIManager.UIAll.NoticesFilter_HideMapWarning = True;
SM::SetupDefaultVisibility();
// Layers
Interface::SetLayerTeams(LayerTeams);
UIManager.UIAll.UILayers.add(LayerTeams);
UIManager.UIAll.UILayers.add(G_LayerScoresTableExtension);
Interface::SetLayerPosition(LayerPosition);
Rules::Attach();

// Prepare match
Score::MatchBegin();
Victory::MatchBegin();

// Initialize values
G_LastUIUpdate = 0;
G_LastBigMessage = 0;
G_LastStatusMessage = 0;
G_AttackingClan = 0;
G_AttackRounds.clear();
G_DefendRounds.clear();

// Prepare map
foreach (Base in Bases) {
	Base.IsActive = True;
	Base.Clan = 0;
}

// Warmup
if (S_UseWarmUp) {
	WarmUp::Initialize(C_WarmUpDuration);
	WarmUp::Start();
}
***

***StartRound***
***
XmlRpc.SendCallback("beginRound", GetRankings());

// Warmup
SetNbFakePlayers(0, 0);
if (S_UseWarmUp && (ClansNbPlayers[0] <= 0 || ClansNbPlayers[1] <= 0)) {
	WarmUp::Initialize(C_WarmUpDuration);
	WarmUp::Start();
}
SetNbFakePlayers(C_NbBots, 0);

SM::UnspawnAllPlayers();
Score::RoundBegin();
Victory::RoundBegin();

// UI
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

// Initialize values
PrepareNextRound();

// Announce attacking player
if (Players.existskey(G_AttackerId)) {
	UIManager.UIAll.BigMessage = """$<{{{Players[G_AttackerId].Name}}}$> is attacking!""";
	G_LastBigMessage = Now;
	UIManager.UIAll.SendNotice(
		"",
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::StartRound, 0);
}

MB_Sleep(1000);

// Set round times
StartTime = Now + 2500;
G_CountdownEndTime = StartTime + S_TimeLimit * 1000;
UIManager.UIAll.CountdownEndTime = G_CountdownEndTime;
EndTime = G_CountdownEndTime + S_TimeLimitCapturing * 1000;

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
***

***OnNewPlayer***
***
// Prepare UI for the new player
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) {
	UI.UILayers.clear();
	UI.UILayers.add(LayerPosition);
	
	// Gauge ratio
	UI.GaugeRatio = -1.0;
	
	InitPlayer(Player);
}
***

***OnNewSpectator***
***
// Prepare UI for the new spectator
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.UILayers.clear();
	
	// Gauge ratio
	UI.GaugeRatio = -1.0;
	
	// Spectating
	UI.SpectatorForcedClan = -1;
}
***

***PlayLoop***
***
// Update settings
CheckScriptSettings();

// Perform actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			if (!Player.RequestsSpectate && Now < StartTime) {
				MySpawnPlayer(Player);
			}
		}
	}
}

// Handle pending events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnHit: {
			if (Event.Shooter == Null || Event.Victim == Null) {
				// Discard buggy event
				Discard(Event);
			} else {
				if (Event.Shooter == Event.Victim) {
					// Discard self damage
					Discard(Event);
				} else {
					if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
						if (S_FriendlyFire) {
							// PassOn team hits
							Event.ShooterPoints = -1;
							Score::AddPoints(Event.Shooter, -1);
							PassOn(Event);
						} else {
							// Discard team hits
							Discard(Event);
						}
					} else {
						Event.Damage = 100;
						// Grant points for the hit
						Event.ShooterPoints = 1;
						Score::AddPoints(Event.Shooter, 1);
						if (Event.Shooter.Id != G_AttackerId && Event.Victim.Armor >= 200) {
							// Announce left armor count
							declare ArmorLeft = (Event.Victim.Armor-100)/100;
							switch (ArmorLeft) {
								case 1: {
									UIManager.UIAll.SendNotice(
										"""{{{ArmorLeft}}} armor left!""",
										CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
										CUIConfig::EUISound::TiePoint, 3);
								}
								case 2: {
									UIManager.UIAll.SendNotice(
										"""{{{ArmorLeft}}} armor left!""",
										CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
										CUIConfig::EUISound::TiePoint, 1);
								}
							}
						}
						if (!Event.Victim.IsFakePlayer && !Event.Shooter.IsFakePlayer) {
							XmlRpc.SendCallback("playerHit", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";1;");
						}
						PassOn(Event);
					}
				}
			}
		}
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Victim != Null) {
				if (Event.Victim.Id != G_AttackerId && ClansNbPlayersAlive[3-G_AttackingClan] >= 2) {
					// Announce shot distance
					declare Distance = MathLib::NearestInteger(10*MathLib::Distance(Event.Shooter.Position, Event.Victim.Position))/10.0;
					UIManager.UIAll.SendNotice(
						"""{{{Distance}}}m hit!""",
						CUIConfig::ENoticeLevel::PlayerInfo, Null, CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::Silence, 0);
						
					// Announce left defender count
					declare DefenderLeft = ClansNbPlayersAlive[3-G_AttackingClan]-1;
					switch (DefenderLeft) {
						case 1: {
							UIManager.UIAll.SendNotice(
								"""{{{DefenderLeft}}} defender left!""",
								CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
								CUIConfig::EUISound::TieBreakPoint, 3);
						}
						case 2: {
							UIManager.UIAll.SendNotice(
								"""{{{DefenderLeft}}} defender left!""",
								CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
								CUIConfig::EUISound::TieBreakPoint, 1);
						}
					}
				}
				if (!Event.Victim.IsFakePlayer) {
					if (Event.Shooter == Null) {
						XmlRpc.SendCallback("playerDeath", Event.Victim.Login);
					} else {
						if (!Event.Shooter.IsFakePlayer) {
							XmlRpc.SendCallback("playerKill", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login);
						}
					}
				}
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnCapture: {
			// Goal captured - Attackers win
			Victory::SetRoundWinnerIfNoWinner(G_AttackingClan);
			if (Players.existskey(G_AttackerId) && Event.Player == Players[G_AttackerId]) {
				UIManager.UIAll.BigMessage = """$<{{{Players[G_AttackerId].Name}}}$> captured the goal!""";
				G_LastBigMessage = Now;
				XmlRpc.SendCallback("poleCapture", Event.Player.Login);
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnNearMiss: {
			// Near miss
			if (C_NearMissDist >= 0 && Event.MissDist <= C_NearMissDist) {
				UIManager.UIAll.StatusMessage = GetNearMissMessage(Event);
				G_LastStatusMessage = Now;
			}
			PassOn(Event);
		}
		default: {
			PassOn(Event);
		}
	}
}

// Check for captures
foreach (Pole in BlockPoles) {
	declare Speed = 0;
	if (G_CapturingPossible) {
		foreach (PlayerId in Pole.Sector.PlayersIds) {
			if (Players.existskey(PlayerId) && Players[PlayerId].CurrentClan == G_AttackingClan) {
				Speed += 1;
			}
		}
	}
	Pole.Gauge.Speed = Speed;
}

// UI
if (G_LastUIUpdate + C_UITickInterval < Now) {
	G_LastUIUpdate = Now;
	
	// Clear big message
	if (G_LastBigMessage != 0 && G_LastBigMessage + 4000 < Now) {
		G_LastBigMessage = 0;
		UIManager.UIAll.BigMessage = "";
	}
	
	// Clear big message
	if (G_LastStatusMessage != 0 && G_LastStatusMessage + 4000 < Now) {
		G_LastStatusMessage = 0;
		UIManager.UIAll.StatusMessage = "";
	}
	
	// Player UI
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			// Position
			UpdateLayerPosition(Player);
			
			// Gauge ratio
			if (Player.BlockPole == Null || !G_CapturingPossible) {
				UI.GaugeRatio = -1.0;
			} else {
				UI.GaugeClan = Player.BlockPole.Gauge.Clan;
				UI.GaugeRatio = Player.BlockPole.Gauge.ValueReal;
			}
	
			// Spectating
			UI.SpectatorForcedClan = Player.CurrentClan;
		}
	}
}

// Activate goal
if (Now >= G_CountdownEndTime) {
	if (!G_CapturingPossible) {
		G_CapturingPossible = True;
		UIManager.UIAll.CountdownEndTime = -1;
		UIManager.UIAll.SendNotice(
			"", CUIConfig::ENoticeLevel::MatchInfo,
			Null, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::PhaseChange, 0);
	}
	if (UIManager.UIAll.StatusMessage == "") {
		UIManager.UIAll.StatusMessage = "The goal can now be captured!";
	}
}

// Check round end conditions
if (Now >= EndTime) {
	// Time is up - Defenders win
	Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
} else {
	if (ClansNbPlayersAlive[G_AttackingClan] <= 0) {
		// Attacker eliminated
		Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
	} else {
		if (ClansNbPlayersAlive[3-G_AttackingClan] <= 0) {
			// Defender eliminated
			Victory::SetRoundWinnerIfNoWinner(G_AttackingClan);
		}
	}
}
if (!MB_StopRound && !Victory::NoRoundWinner()) {
	// Round winner found
	MB_StopRound = True;
}
***

***EndRound***
***
XmlRpc.SendCallback("endRound", GetRankings());

EndTime = Now;
foreach (Pole in BlockPoles) {
	Pole.Gauge.Speed = 0;
}
UIManager.UIAll.StatusMessage = "";

// Evaluate round
declare Message = "Round Draw";
if (Victory::IsRoundWinner(G_AttackingClan) && Players.existskey(G_AttackerId)) {
	Message = """$<{{{Players[G_AttackerId].Name}}}$> wins the round!""";
	if (Players.existskey(G_AttackerId) && !Players[G_AttackerId].IsFakePlayer) {
		XmlRpc.SendCallback("attackerWon", Players[G_AttackerId].Login);
	}
	if (Players[G_AttackerId].Score != Null) {
		Players[G_AttackerId].Score.RoundPoints += C_AttackRoundBonus;
	}
} else {
	Message = """$<{{{Teams[2-G_AttackingClan].ColorText}}}Defenders$> win the round!""";
	foreach (DefenderId in G_DefendingPlayerIds) {
		if (Players.existskey(DefenderId) && Players[DefenderId].Score != Null) {
			Players[DefenderId].Score.RoundPoints += C_DefendRoundBonus;
		}
	}
	
}
UIManager.UIAll.BigMessage = Message;
G_LastBigMessage = Now;

MB_Sleep(1500);

SM::UnspawnAllPlayers();
UIManager.UIAll.CountdownEndTime = -1;

UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

MB_Sleep(2000);

Score::RoundEnd();
Victory::RoundEnd();

// Check match end conditions
foreach (Score in Scores) {
	if (Score.Points >= S_PointsLimit) {
		// Match winner found
		MB_StopMap = True;
		break;
	}
}
***

***EndMap***
***
XmlRpc.SendCallback("endMap", GetRankings());

Score::MatchEnd();
Victory::MatchEnd();

// UI
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;

// Announce victorious clan
declare Message = "Match Draw";
declare CUser Winner <=> Null;
declare MaxPoints = 0;
foreach (Score in Scores) {
	if (Score.Points > MaxPoints) {
		MaxPoints = Score.Points;
		Winner <=> Score.User;
	}
}
if (Winner != Null) {
	Message = """$<{{{Winner.Name}}}$> wins the map!""";
}
UIManager.UIAll.BigMessage = Message;
G_LastBigMessage = Now;

MB_Sleep(3000);

Mode::Ladder_CloseMatch();
***

***EndServer***
***

// UI Cleanup
UIManager.UILayerDestroy(LayerTeams);
***

/*****************************************************
	FUNCTIONS
*****************************************************/

// Spawn player
Void MySpawnPlayer(CSmPlayer _Player) {
	if (C_LogEnabled) MB_Log("MySpawnPlayer("^_Player.Login);
	
	if (Now < StartTime) {
		// Get spawn
		declare SpawnId = NullId;
		foreach (Spawn in BlockSpawns) {
			if (_Player.Id == G_AttackerId && Spawn.Base.Clan == G_AttackingClan) {
				SpawnId = Spawn.Id;
				break;
			} else {
				if (_Player.Id != G_AttackerId && G_DefendingPlayerIds.exists(_Player.Id) && Spawn.Base.Clan != G_AttackingClan) {
					SpawnId = Spawn.Id;
					break;
				}
			}
		}
		
		// Set values depending on player clan
		if (SpawnId != NullId) {
			if (_Player.Id == G_AttackerId) {
				// Attacker
				if (S_LaserAttackers) {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
				} else {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
				}
				_Player.AmmoGain = C_AttackerAmmoGain;
				_Player.ArmorMax = G_DefendingPlayerIds.count * 100;
				
				// Spawn player
				SM::SpawnPlayer(_Player, G_AttackingClan, BlockSpawns[SpawnId], StartTime);
			} else {
				// Defender
				This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
				_Player.AmmoGain = C_DefenderAmmoGain;
				_Player.ArmorMax = 100;
				
				// Spawn player
				SM::SpawnPlayer(_Player, 3-G_AttackingClan, BlockSpawns[SpawnId], StartTime);
			}
		}
	}
}

Integer GetHighestValue(Integer[Ident] _RoundsArray) {
	declare HighestValue = 0;
	foreach (Id => Value in _RoundsArray) {
		if (Value > HighestValue) {
			HighestValue = Value;
		}
	}
	return HighestValue;
}

// Init player
Void InitPlayer(CSmPlayer _Player, Boolean _Forced) {
	// Init atk/def values
	if (_Forced) {
		// Full init
			G_AttackRounds[_Player.Id] = 0;
			G_DefendRounds[_Player.Id] = 0;
			G_LastAttackTime[_Player.Id] = 0;
	} else {
		if (!G_AttackRounds.existskey(_Player.Id)) {
			G_AttackRounds[_Player.Id] = GetHighestValue(G_AttackRounds);
		}
		if (!G_DefendRounds.existskey(_Player.Id)) {
			G_DefendRounds[_Player.Id] = GetHighestValue(G_DefendRounds);
		}
		if (!G_LastAttackTime.existskey(_Player.Id)) {
			G_LastAttackTime[_Player.Id] = Now;
		}
	}
}

Void InitPlayer(CSmPlayer _Player) {
	InitPlayer(_Player, False);
}

// Generates manialink for ScoresTableExtension layer
Text GetScoresTableExtensionLayer() {
	return """
		<frame posn="0 -49.1">
			<quad sizen="30 5" halign="center" valign="center" bgcolor="0006"/>
			<label scale="0.7" halign="center" valign="center" text="$bbbPoints Limit: {{{S_PointsLimit}}}"/>
		</frame>""";
}

// Checks for changed script settings and performs updates
Void CheckScriptSettings() {
	// Check max defender count
	if (S_MaxDefenderCount <= 0) {
		G_MaxDefenderCount = 3;
	} else {
		G_MaxDefenderCount = S_MaxDefenderCount;
	}
	
	// Update gameplay version
	if (S_Beta2Gameplay && GameplayVersion != 1) {
		GameplayVersion = 1;
	} else {
		if (!S_Beta2Gameplay && GameplayVersion != 0) {
			GameplayVersion = 0;
		}
	}
	
	// Update points limit
	if (Cache_S_PointsLimit != S_PointsLimit) {
		Cache_S_PointsLimit = S_PointsLimit;
		G_LayerScoresTableExtension.ManialinkPage = GetScoresTableExtensionLayer();
	}
}

// Check if clublink defined team names
Boolean TeamsHaveClublinkNames() {
	for (Index, 0, 1) {
		switch (Teams[Index].Name) {
			case "Blue": {}
			case "Red": {}
			case "Attacker": {}
			case "Defender": {}
			default: {
				return True;
			}
		}
	}
	return False;
}


// Change sides and stuff
Void PrepareNextRound() {
	if (C_LogEnabled) MB_Log("PrepareNextRound()");
	
	CheckScriptSettings();
	SM::UnspawnAllPlayers();
	G_CapturingPossible = False;
	G_AttackerId = NullId;
	
	// Get attacking clan
	if (C_AttackerClan != 1 && C_AttackerClan != 2) {
		G_AttackingClan = MathLib::Rand(1,2);
	} else {
		G_AttackingClan = C_AttackerClan;
	}
	// Set team names
	if (!TeamsHaveClublinkNames()) {
		Teams[G_AttackingClan-1].Name = "Attacker";
		Teams[2-G_AttackingClan].Name = "Defenders";
	}
	
	// Assign spawns
	foreach (Spawn in BlockSpawns) {
		switch (Spawn.Tag) {
			case "SpawnAttack": {
				Spawn.Base.Clan = G_AttackingClan;
			}
			case "SpawnDefense": {
				Spawn.Base.Clan = 3-G_AttackingClan;
			}
		}
	}
	// Assign poles
	foreach (Pole in BlockPoles) {
		Pole.Gauge.Max = MathLib::NearestInteger(S_CaptureTime * 1000);
		Pole.Gauge.ValueReal = 0.0;
		
		Pole.Base.Clan = G_AttackingClan;
		Pole.Gauge.Clan = G_AttackingClan;
	}
	
	// Get attack player
	declare FewestAttackRounds = -1;
	
	foreach (Player in Players) {
		InitPlayer(Player);
		if (!Player.RequestsSpectate) {
			if (G_AttackRounds[Player.Id] < FewestAttackRounds || FewestAttackRounds < 0) {
				G_AttackerId = Player.Id;
				FewestAttackRounds = G_AttackRounds[Player.Id];
			}
		}
	}
	
	// Get defending players
	declare Ident[Integer] FewestDefendRoundPlayerIds;
	G_DefendingPlayerIds = Ident[];
	
	foreach (Player in Players) {
		if (Player.Id != G_AttackerId) {
			// Fill empty defender spots
			for (Index, 1, G_MaxDefenderCount) {
				if (!FewestDefendRoundPlayerIds.existskey(Index)) {
					FewestDefendRoundPlayerIds[Index] = Player.Id;
					break;
				}
			}
			if (!Player.IsFakePlayer) {
				// Replace players who have played more often
				if (!FewestDefendRoundPlayerIds.exists(Player.Id)) {
					foreach (Index => PlayerId in FewestDefendRoundPlayerIds) {
						if (G_DefendRounds[Player.Id] < G_DefendRounds[PlayerId]) {
							FewestDefendRoundPlayerIds[Index] = Player.Id;
							break;
						}
					}
				}
				// Replace bots by players
				if (!FewestDefendRoundPlayerIds.exists(Player.Id)) {
					foreach (Index => PlayerId in FewestDefendRoundPlayerIds) {
						if (Players[PlayerId].IsFakePlayer) {
							FewestDefendRoundPlayerIds[Index] = Player.Id;
							break;
						}
					}
				}
			}
		}
	}
	
	foreach (PlayerId in FewestDefendRoundPlayerIds) {
		G_DefendRounds[PlayerId] += 1;
		G_DefendingPlayerIds.add(PlayerId);
	}
	
	// Set players clans
	foreach (Player in Players) {
		if (Player.Id == G_AttackerId) {
			// Attacker
			This.SetPlayerClan(Player, G_AttackingClan);
			
			G_AttackRounds[Player.Id] += 1;
		} else {
			if (G_DefendingPlayerIds.exists(Player.Id)) {
				// Defender
				This.SetPlayerClan(Player, 3-G_AttackingClan);
			} else {
				// Inactive
				This.SetPlayerClan(Player, 0);
			}
		}
	}
}

// Update a player position UI
Void UpdateLayerPosition(CSmPlayer _Player) {
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		declare LibInterface_LastPosCurrent for _Player = -1;
		declare netwrite Integer Net_LibInterface_LayerInfoUpdate for UI;
		declare netwrite Integer Net_LibInterface_PosTotal for UI;
		declare netwrite Integer Net_LibInterface_PosCurrent for UI;
		
		Net_LibInterface_LayerInfoUpdate = Now;
		Net_LibInterface_PosTotal = Scores.count;
		Net_LibInterface_PosCurrent = Scores.keyof(_Player.Score) + 1;
	}
}

// Creates message for near miss
Text GetNearMissMessage(CSmModeEvent _Event) {
	// Catch invalid events
	if (_Event.Type != CSmModeEvent::EType::OnNearMiss) return "";	// Wrong event type
	if (_Event.MissDist <= 0.0) return "";							// Invalid miss distance
	if (_Event.Shooter == Null || _Event.Victim == Null) return "";	// Invalid players
	
	// Get message text
	declare Message = "";
	declare Dist = MathLib::NearestInteger(_Event.MissDist * 1000);
	if (Dist >= 10) {
		Message = (Dist/10.0)^"cm!";
	} else {
		Dist = MathLib::NearestInteger(_Event.MissDist * 10000);
		if (Dist >= 10) {
			Message = (Dist/10.0)^"mm!";
		} else {
			Dist = MathLib::NearestInteger(_Event.MissDist * 10000000);
			Message = (Dist/10.0)^"¬µm!";
		}
	}
	return TextLib::Compose(_("$<%1$> missed $<%2$> by %3"), _Event.Shooter.Name, _Event.Victim.Name, Message);
}

// Get the current rankings for xmlrpc callbacks
Text GetRankings() {
	declare PlayerList = "";
	foreach (Score in Scores) {
		PlayerList ^= Score.User.Login^":"^Score.Points^";";
	}
	return PlayerList;
}
