/* -------------------- */
//	1337 Game Mode		//
//	(Custom Elite)		//
//	Made by steeffeen	//
/* -------------------- */

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const CompatibleMapTypes	"EliteArena"
#Const ScriptVersion		"0.0.1 (2013-01-15)"

/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/Rules.Script.txt" as Rules
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM

/* SETTINGS */
// Round settings
#Setting	S_TimeLimit				45		as _("Time limit per round (seconds)")
#Setting	S_TimeLimitCapturing	15		as _("Time limit after the goal becomes active (seconds)")
#Setting	S_RoundsToWin			9		as _("Rounds to win a map")
#Setting	S_RoundGapToWin			2		as _("Rounds gap to win a map")
#Setting	S_RoundsLimit			20		as _("Total rounds limit per map (First team reaching X wins)")
// Gameplay settings
#Setting	S_CaptureTime			1.5		as _("Time needed to capture goals (seconds)")
#Setting	S_TrainingFactor		2.0		as _("Training factor (Multiplies time and hits to be landed)")
#Setting	S_LaserAttackers		True	as _("Attackers get lasers")
#Setting	S_FriendlyFire			False	as _("Friendly Fire (Damage team mates)")

/* CONSTANTS */
#Const	C_LogEnabled				False		// Enable/disable logging
#Const	C_UITickInterval			200			// Interval of UI refreshes
// Gameplay constants
#Const	C_AttackerAmmoGain			1.1			// Attacker ammunition gain rate
#Const	C_DefenderAmmoGain			1.0			// Defender ammunition gain rate
#Const	C_UseLaserVsBullets			True		// Whether lasers can destroy rockets
#Const	C_NbBots					0			// Number of bots per team

/* GLOBALES */
declare Integer G_LastUIUpdate;				// Time of last UI update
declare Integer G_LastBigMessage;			// Time of last big message
declare Integer G_AttackingClan;			// Currently attacking clan
declare Boolean G_CapturingPossible;		// Whether it's possible to capture the goal
declare Integer G_CountdownEndTime;			// Countdown end time
declare Integer[Integer] G_ClanPlayersNb;	// Number of players playing per clan

/*****************************************************
	EXTENSIONS
*****************************************************/
***StartServer***
***
log("1337.Script.txt loaded!");
log("Version: "^ScriptVersion);

MB_UseLogging = C_LogEnabled;

// Game settings
UseClans = True;
UseLaserVsBullets = C_UseLaserVsBullets;

// Init variables
MB_UseSectionRound = True;

Mode::Ladder_OpenMatch_All();
***

***StartMap***
***
// UI
UIManager.ResetAll();
SM::SetupDefaultVisibility();
// Layers
declare LayerTeams <=> UIManager.UILayerCreate();
Interface::SetLayerTeams(LayerTeams);

// Rules
declare ModeName = "1337";
declare ModeRules = "$<$1f1Elite$> game mode for $<$4f4training$> matches.";
Rules::Create(ModeName, ModeRules);
Rules::Attach();

// Prepare match
Score::MatchBegin();
Victory::MatchBegin();

// Initialize values
G_LastUIUpdate = 0;
G_AttackingClan = 0;
ClanScores[1] = 0;
ClanScores[2] = 0;

// Prepare map
foreach (Base in Bases) {
	Base.IsActive = True;
	Base.Clan = 0;
}
***

***StartRound***
***
SM::UnspawnAllPlayers();
Score::RoundBegin();
Victory::RoundBegin();

// Set bots
SetNbFakePlayers(C_NbBots, C_NbBots);

// UI
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

// Initialize values
PrepareNextRound();

UIManager.UIAll.BigMessage = """Team {{{ClanName(G_AttackingClan)}}} is attacking!""";
G_LastBigMessage = Now;

// Set round times
StartTime = Now + 4500;
G_CountdownEndTime = MathLib::NearestInteger(StartTime + S_TimeLimit * S_TrainingFactor * 1000);
UIManager.UIAll.CountdownEndTime = G_CountdownEndTime;
EndTime = MathLib::NearestInteger(G_CountdownEndTime + S_TimeLimitCapturing * S_TrainingFactor * 1000);

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
***

***OnNewPlayer***
***
// Prepare UI for the new player
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) {
	UI.UILayers.clear();
	UI.UILayers.add(LayerTeams);
	
	// Gauge ratio
	UI.GaugeRatio = -1.0;
}
***

***OnNewSpectator***
***
// Prepare UI for the new spectator
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.UILayers.clear();
	UI.UILayers.add(LayerTeams);
	
	// Gauge ratio
	UI.GaugeRatio = -1.0;
	
	// Spectating
	UI.SpectatorForcedClan = -1;
}
***

***PlayLoop***
***
// Perform actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			if (!Player.RequestsSpectate) {
				if (Now < StartTime) {
					foreach (Spawn in BlockSpawns) {
						if (Spawn.Base.Clan == Player.RequestedClan) {
							MySpawnPlayer(Player, Spawn);
							break;
						}
					}
				}
			}
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			// Spawned player
			if (Player.CurrentClan != Player.RequestedClan) {
				// Unspawn player that wants to change clan
				UnspawnPlayer(Player);
			}
		}
	}
}

// Handle pending events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnHit: {
			if (Event.Shooter == Null || Event.Victim == Null) {
				// Discard buggy event
				Discard(Event);
			} else {
				if (Event.Shooter == Event.Victim) {
					// Discard self damage
					Discard(Event);
				} else {
					if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
						if (S_FriendlyFire) {
							// PassOn team hits
							PassOn(Event);
						} else {
							// Discard team hits
							Discard(Event);
						}
					} else {
						Event.Damage = 100;
						// Grant points for the hit
						Event.ShooterPoints = 1;
						Score::AddPoints(Event.Shooter, 1);
						PassOn(Event);
					}
				}
			}
		}
		case CSmModeEvent::EType::OnCapture: {
			// Goal captured - Attackers win
			Victory::SetRoundWinnerIfNoWinner(G_AttackingClan);
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			// Player kills himself
			if (!Event.Player.RequestsSpectate) {
				if (Now < StartTime) {
					foreach (Spawn in BlockSpawns) {
						if (Spawn.Base.Clan == Event.Player.RequestedClan) {
							MySpawnPlayer(Event.Player, Spawn);
							break;
						}
					}
				}
			}
			PassOn(Event);
		}
		default: {
			PassOn(Event);
		}
	}
}

// Check for captures
foreach (Pole in BlockPoles) {
	declare Speed = 0;
	if (G_CapturingPossible) {
		foreach (PlayerId in Pole.Sector.PlayersIds) {
			if (Players.existskey(PlayerId) && Players[PlayerId].CurrentClan == G_AttackingClan) {
				Speed += 1;
			}
		}
	}
	Pole.Gauge.Speed = Speed;
}

// UI
if (G_LastUIUpdate + C_UITickInterval < Now) {
	G_LastUIUpdate = Now;
	
	// Clear big message
	if (G_LastBigMessage != 0 && G_LastBigMessage + 4000 < Now) {
		G_LastBigMessage = 0;
		
		UIManager.UIAll.BigMessage = "";
	}
	
	// Player UI
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			// Gauge ratio
			if (Player.BlockPole == Null || !G_CapturingPossible) {
				UI.GaugeRatio = -1.0;
			} else {
				UI.GaugeClan = Player.BlockPole.Gauge.Clan;
				UI.GaugeRatio = Player.BlockPole.Gauge.ValueReal;
			}
	
			// Spectating
			UI.SpectatorForcedClan = Player.CurrentClan;
		}
	}
}

// Activate goal
if (Now >= G_CountdownEndTime && !G_CapturingPossible) {
	G_CapturingPossible = True;
	UIManager.UIAll.CountdownEndTime = -1;
	UIManager.UIAll.SendNotice(
		"The goal can now be captured!", CUIConfig::ENoticeLevel::MatchInfo,
		Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::PhaseChange, 0);
}

// Check round end conditions
if (Now >= EndTime) {
	// Time is up
	if (ClansNbPlayers[G_AttackingClan] > 0 && ClansNbPlayers[3-G_AttackingClan] > 0) {
		// Defenders win
		Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
	} else {
		// Draw
		Victory::SetRoundDrawIfNoWinner();
	}
} else {
	if (ClansNbPlayers[G_AttackingClan] > 0 && ClansNbPlayersAlive[G_AttackingClan] <= 0) {
		// Attacker eliminated
		Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
	} else {
		if (ClansNbPlayers[3-G_AttackingClan] > 0 && ClansNbPlayersAlive[3-G_AttackingClan] <= 0) {
			// Defender eliminated
			Victory::SetRoundWinnerIfNoWinner(G_AttackingClan);
		}
	}
}
if (!MB_StopRound && !Victory::NoRoundWinner()) {
	// Round winner found
	MB_StopRound = True;
}
***

***EndRound***
***
// Evaluate round
declare Message = "Round Draw";
if (!Victory::IsRoundDraw()) {
	for (Index, 1, 2) {
		if (Victory::IsRoundWinner(Index)) {
			// Team 'Index' wins the round
			ClanScores[Index] += 1;
			Message = """Team {{{ClanName(Index)}}} wins the round!""";
			break;
		}
	}
}
UIManager.UIAll.BigMessage = Message;
G_LastBigMessage = Now;

MB_Sleep(3000);

StartTime = -1;
EndTime = -1;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.CountdownEndTime = -1;

// Check match end conditions
Victory::SetMatchWinnerFromScore(S_RoundsToWin, S_RoundGapToWin, S_RoundsLimit);
if (!Victory::NoMatchWinner()) {
	// Match winner found
	MB_StopMap = True;
}

Score::RoundEnd();
Victory::RoundEnd();
***

***EndMap***
***
Score::MatchEnd();
Victory::MatchEnd();

// UI
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;

// Announce victorious clan
declare Message = "Match Draw";
if (!Victory::IsMatchDraw()) {
	for (Index, 1, 2) {
		if (Victory::IsMatchWinner(Index)) {
			// Team 'Index' wins the match
			Message = """Team {{{ClanName(Index)}}} wins the match!""";
			break;
		}
	}
}
UIManager.UIAll.BigMessage = Message;
G_LastBigMessage = Now;

MB_Sleep(3000);

// UI Cleanup
UIManager.UILayerDestroy(LayerTeams);
***

***EndServer***
***
Mode::Ladder_CloseMatch();
***

/*****************************************************
	FUNCTIONS
*****************************************************/

// Spawn player
Void MySpawnPlayer(CSmPlayer _Player, CSmBlockSpawn _Spawn) {
	if (C_LogEnabled) MB_Log("MySpawnPlayer("^_Player.Login^","^_Spawn.Tag);
	
	if (Now < StartTime) {
		if (_Player.RequestedClan == G_AttackingClan) {
			// Attacker
			if (S_LaserAttackers) {
				This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
			} else {
				This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
			}
			_Player.AmmoGain = C_AttackerAmmoGain;
		} else {
			// Defender
			This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
			_Player.AmmoGain = C_DefenderAmmoGain;
		}
		
		declare ArmorMax = MathLib::NearestInteger(S_TrainingFactor * G_ClanPlayersNb[3-_Player.RequestedClan] * 100);
		if (ArmorMax < 100) {
			ArmorMax = 100;
		}
		_Player.ArmorMax = ArmorMax;
		
		SM::SpawnPlayer(_Player, _Player.RequestedClan, _Spawn, StartTime);
	}
}

// Change sides and stuff
Void PrepareNextRound() {
	if (C_LogEnabled) MB_Log("PrepareNextRound()");
	
	G_CapturingPossible = False;
	
	if (G_AttackingClan == 0) {
		G_AttackingClan = MathLib::Rand(1,2);
	} else {
		G_AttackingClan = 3-G_AttackingClan;
	}
	
	foreach (Spawn in BlockSpawns) {
		switch (Spawn.Tag) {
			case "SpawnAttack": {
				Spawn.Base.Clan = G_AttackingClan;
			}
			case "SpawnDefense": {
				Spawn.Base.Clan = 3-G_AttackingClan;
			}
		}
	}
	foreach (Pole in BlockPoles) {
		Pole.Gauge.Max = MathLib::NearestInteger(S_TrainingFactor * S_CaptureTime * 1000);
		Pole.Gauge.ValueReal = 0.0;
		
		Pole.Base.Clan = G_AttackingClan;
		Pole.Gauge.Clan = G_AttackingClan;
	}
	
	// Gather number of players
	G_ClanPlayersNb[1] = 0;
	G_ClanPlayersNb[2] = 0;
	
	foreach (Player in Players) {
		if (!Player.RequestsSpectate) {
			G_ClanPlayersNb[Player.RequestedClan] += 1;
		}
	}
}

// Returns colored clan name
Text ClanName(Integer _ClanNb) {
	switch (_ClanNb) {
		case 1: {
			return "$<$00fBlue$>";
		}
		case 2: {
			return "$<$f00Red$>";
		}
	}
	return ""^_ClanNb;
}