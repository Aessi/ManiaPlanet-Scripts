/************************************
*	Athletics Game Mode				*
*	Author: steeffeen				*
*	Contact: schteffens@gmail.com	*
************************************/

/* TODO:
- tabs
*/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Chrono.Script.txt" as Chrono
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/Top2.Script.txt" as Top
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

#Const	CompatibleMapTypes	"AthleticsArena"
#Const	Version 			"0.4 (2013-02-26)"

// SETTINGS
#Setting	S_TimeLimit		15	as _("Time limit per map (minutes)")

// CONSTANTS
// Gameplay contants
#Const	C_PointsPerDiscipline	100.0	// Points granted to the winner of a certain discipline
#Const	C_Rounds				2		// Rounds to finish a rounds based discipline
// UI contants
#Const	C_UITickRate			250		// Time between ui updates

// TEXTS
#Const	C_LobbyName				"Lobby"	// Name of lobby

// Discipline types
#Const	C_DisciplineTypes		[1 => "LongJump", 2 => "HighJump", 3 => "Run", 4 => "Rounds"]

// GLOBALES
declare Integer G_LastUIUpdate;				// Time of last ui update
declare Integer[Text] G_Disciplines;		// Disciplines of current map
declare Real[Text] G_DisciplineRecords;		// Record per discipline
declare Integer[Text] G_DisciplineCPCount;	// Count of checkpoints of rounds based disciplines
declare Text[Ident] G_DisciplinePorts;		// Ports of the disciplines
declare Text[Ident] G_DisciplineGoals;		// Goals of the disciplines

***StartServer***
***
log("Athletics.Script.txt loaded!");
log("Version: "^Version);

// Gameplay
UseClans = False;
UsePvPWeapons = False;
UsePvPCollisions = False;

// UI Layers
Chrono::Load();
// Utility layer
declare UtilityLayer <=> UIManager.UILayerCreate();
UtilityLayer.ManialinkPage = GetUtilityLayerManialink();
// Markers layer
declare MarkersLayer <=> UIManager.UILayerCreate();
MarkersLayer.Type = CUILayer::EUILayerType::Markers;
// Discipline rankings layer
declare DisciplineRankingsLayer <=> UIManager.UILayerCreate();
DisciplineRankingsLayer.Type = CUILayer::EUILayerType::AltMenu;
DisciplineRankingsLayer.ManialinkPage = GetDisciplineRankingsLayer();
// Rules
SpawnScreen::CreateRules("Athletics", "Rock dat shit!");
***

***StartMap***
***
// UI
UIManager.ResetAll();
UIManager.UIAll.AltMenuNoDefaultScores = True;
UIManager.UIAll.AltMenuNoCustomScores = True;
SM::SetupDefaultVisibility();
// Layers
UIManager.UIAll.UILayers.add(MarkersLayer);
SpawnScreen::AttachRules();
SpawnScreen::CreateScores();
SpawnScreen::AttachScores();
UIManager.UIAll.UILayers.add(UtilityLayer);
UIManager.UIAll.UILayers.add(DisciplineRankingsLayer);

// Initialize map
InitMap();
foreach (Spawn in BlockSpawns) {
	Spawn.Base.Clan = 0;
	Spawn.Base.IsActive = True;
}
foreach (Pole in BlockPoles) {
	Pole.Base.Clan = 0;
	Pole.Base.IsActive = True;
	Pole.Gauge.Clan = 0;
	Pole.Gauge.ValueReal = 1.0;
}
UIManager.UIAll.Hud3dMarkers = GetHud3dMarkers();
MarkersLayer.ManialinkPage = GetMarkersLayerManialink();

// Tabs
Tabs::Load();
declare CUILayer TabsLayer <=> CreateTabPaneLayer(
	GetDisciplinesImages(G_Disciplines), 25, 15, True);
TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
UIManager.UIAll.UILayers.add(TabsLayer);
// Scores table
ScoresTable::Load();
ScoresTable::SetColumnsWidth(2., 2., 3., 19., 1.5, 1.5, 0., 0., 0., 0., 5.);
ScoresTable::SetColumnsName("", "", "", "", "Score");
ScoresTable::SetTableFormat(2, 8);
ScoresTable::SetTableWidth(239.);
ScoresTable::Build();
ScoresTable::GetLayerScoresTable().Type = CUILayer::EUILayerType::Normal;

// Initialize scores
Score::MatchBegin();
InitAllPlayersScores(True);

// Start game
StartTime = Now + 3000;
EndTime = StartTime + S_TimeLimit * 60000;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
***

***OnNewPlayer***
***
declare Text Discipline for Player;
Discipline = "";

InitPlayerScore(Player.Score, False);
UpdatePlayerScore(Player.Score);

declare UI <=> UIManager.GetUI(Player);
if (UI != Null) {
	Tabs::UseTabs(UI, "ScoresTab");
}
***

***PlayLoop***
***
// Actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Spawn the player
			MySpawnPlayer(Player);
			Chrono::Start(Player.Id, Player.StartTime-Now);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			declare Discipline for Player = "";
			switch (Discipline) {
				case "": {
					// LOBBY
					if (Player.BlockPole != Null && G_DisciplinePorts.existskey(Player.BlockPole.Id)) {
						Discipline = G_DisciplinePorts[Player.BlockPole.Id];
						UnspawnPlayer(Player);
					}
				}
				default: {
					switch (G_Disciplines[Discipline]) {
						case 1: {
							// Long jumping
							if (Player.IsTouchingGround) {
								// Check for jump length
								declare AirTimeBegin for Player = -1;
								if (AirTimeBegin >= 0) {
									declare Vec3 AirTimeBeginPosition for Player;
									declare Distance = MathLib::Distance(AirTimeBeginPosition, Player.Position);
									EvaluateTry(Player, Distance, False);
									AirTimeBegin = -1;
								}
							} else {
								declare AirTimeBegin for Player = -1;
								if (AirTimeBegin < 0) {
									// Begin air time
									AirTimeBegin = Now;
									declare Vec3 AirTimeBeginPosition for Player;
									AirTimeBeginPosition = Player.Position;
								}
							}
						}
						case 2: {
							// High jumping
							declare LastHeight for Player = 0.0;
							declare JumpStartHeight for Player = 0.0;
							declare MaxJumpHeight for Player = 0.0;
							declare HighJumpStart for Player = False;
							
							if (Player.IsTouchingGround) {
								// Track jump start height
								JumpStartHeight = Player.Position.Y;
								MaxJumpHeight = 0.0;
							} else {
								// Check for jump height
								if (Player.Position.Y > LastHeight) {
									HighJumpStart = True;
									if (Player.Position.Y-JumpStartHeight > MaxJumpHeight) {
										// Height increased
										MaxJumpHeight = Player.Position.Y-JumpStartHeight;
									}
								} else {
									if (HighJumpStart) {
										// Evaluate try
										EvaluateTry(Player, MaxJumpHeight, False);
										MaxJumpHeight = 0.0;
									}
									HighJumpStart = False;
								}
							}
							LastHeight = Player.Position.Y;
						}
						case 3: {
							// Run
							if (Player.BlockPole != Null && G_DisciplineGoals.existskey(Player.BlockPole.Id)) {
								if (Discipline == G_DisciplineGoals[Player.BlockPole.Id]) {
									// Player reached finish
									declare Time = Now - Player.StartTime;
									EvaluateTry(Player, Time/1000.0, True);
									UnspawnPlayer(Player);
								}
							}
						}
						case 4: {
							// Rounds
							if (Player.BlockPole != Null && G_DisciplineGoals.existskey(Player.BlockPole.Id) && Discipline == G_DisciplineGoals[Player.BlockPole.Id]) {
								// Player reached cp
								declare RoundsStartId for Player = NullId;
								declare RoundsCPs for Player = Ident[];
								declare RoundsCount for Player = 0;
								declare UI <=> UIManager.GetUI(Player);
								
								if (RoundsStartId == NullId) {
									// Try just started
									RoundsStartId = Player.BlockPole.Id;
									if (UI != Null) {
										UI.SendNotice(
											"""{{{(Now-Player.StartTime)/1000.0}}}""", CUIConfig::ENoticeLevel::Default, 
											Null, CUIConfig::EAvatarVariant::Default, 
											CUIConfig::EUISound::Checkpoint, 4);
									}
								} else {
									if (Player.BlockPole.Id == RoundsStartId) {
										// Start reached again
										if (RoundsCPs.count+1 >= G_DisciplineCPCount[Discipline]) {
											// Round finished
											RoundsCount += 1;
											RoundsCPs.clear();
											
											if (RoundsCount >= C_Rounds) {
												// Run finished
												declare Time = Now - Player.StartTime;
												EvaluateTry(Player, Time/1000.0, True);
												if (UI != Null) {
													UI.SendNotice(
														"", CUIConfig::ENoticeLevel::Default, 
														Null, CUIConfig::EAvatarVariant::Default, 
														CUIConfig::EUISound::Finish, 0);
												}
												UnspawnPlayer(Player);
											} else {
												if (UI != Null) {
													UI.SendNotice(
														"""Round {{{RoundsCount}}}: {{{(Now-Player.StartTime)/1000.0}}}""", CUIConfig::ENoticeLevel::Default, 
														Null, CUIConfig::EAvatarVariant::Default, 
														CUIConfig::EUISound::Checkpoint, 1);
												}
											}
										}
									} else {
										// CP reached
										if (!RoundsCPs.exists(Player.BlockPole.Id)) {
											RoundsCPs.add(Player.BlockPole.Id);
											if (UI != Null) {
												UI.SendNotice(
													"""CP {{{RoundsCPs.count}}}: {{{(Now-Player.StartTime)/1000.0}}}""", CUIConfig::ENoticeLevel::Default, 
													Null, CUIConfig::EAvatarVariant::Default, 
													CUIConfig::EUISound::Checkpoint, 1);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

// Handle events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Victim != Null && Event.Shooter == Null) {
				declare Text Discipline for Event.Victim;
				switch (Discipline) {
					case "": {
					}
					default: {
						switch (G_Disciplines[Discipline]) {
							case 1: {
								// Long jumping - Check for jump length
								declare AirTimeBegin for Event.Victim = -1;
								if (AirTimeBegin >= 0) {
									declare Vec3 AirTimeBeginPosition for Event.Victim;
									declare Distance = MathLib::Distance(AirTimeBeginPosition, Event.Victim.Position);
									EvaluateTry(Event.Victim, Distance, False);
									AirTimeBegin = -1;
								}
							}
						}
					}
				}
				UnspawnPlayer(Event.Victim);
				Discard(Event);
			} else {
				PassOn(Event);
			}
		}
		case CSmModeEvent::EType::OnHit: {
			Discard(Event);
		}
		default: {
			PassOn(Event);
		}
	}
}

// UI updates
if (G_LastUIUpdate + C_UITickRate < Now) {
	G_LastUIUpdate = Now;
	
	// Players
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			// Update utility layer
			UpdateUtilityLayer(Player, UI);
			
			// Update discipline in UI
			declare Discipline as DisciplinePlayer for Player = "";
			declare netwrite Discipline as DisciplineUI for UI = "";
			DisciplineUI = DisciplinePlayer;
		}
	}
	
	// Spectators
	foreach (Spectator in Spectators) {
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI != Null) {
			// Update discipline in UI
			declare netwrite Text Discipline for UI;
			Discipline = "";
		}
	}
}

// Map end conditions
if (Now >= EndTime) {
	MB_StopMap = True;
}
***

***EndMap***
***
Score::MatchEnd();

MarkersLayer.ManialinkPage = "";
UIManager.UIAll.Hud3dMarkers = "";
foreach (Player in Players) {
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) {
		declare netwrite Text Discipline for UI;
		Discipline = "";
		Chrono::Destroy(Player.Id);
	}
}

declare CUser Winner <=> Null;
declare Best = 0;
foreach (Score in Scores) {
	if (Score.Points > Best) {
		Winner = Score.User;
		Best = Score.Points;
	}
}
declare Message = "Match Draw";
if (Winner != Null) {
	Message = """$<{{{Winner.Name}}}$> wins the map!""";
}
UIManager.UIAll.BigMessage = Message;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

MB_Sleep(4000);
***

***EndServer***
***
// UI cleanup
Chrono::Unload();
SpawnScreen::DestroyRules();
SpawnScreen::DestroyScores();
UIManager.UILayerDestroy(UtilityLayer);
***

// Get discipline name of a goal
Text GetDisciplineName(CSmBlockPole _Pole) {
	for (Index, 0, TextLib::Length(_Pole.Tag)-1) {
		if (TextLib::SubString(_Pole.Tag, Index, 1) == ":") {
			return TextLib::SubString(_Pole.Tag, 0, Index);
		}
	}
	return "";
}

// Get discipline type of a goal
Text GetGoalType(CSmBlockPole _Pole) {
	for (Index, 0, TextLib::Length(_Pole.Tag)-1) {
		if (TextLib::SubString(_Pole.Tag, Index, 1) == ":") {
			return TextLib::SubString(_Pole.Tag, Index+2, TextLib::Length(_Pole.Tag)-2-Index);
		}
	}
	return "";
}

// Gather disciplines and stuff of the current map
Void InitMap() {
	G_Disciplines.clear();
	G_DisciplineRecords.clear();
	G_DisciplinePorts.clear();
	G_DisciplineGoals.clear();
	G_DisciplineCPCount.clear();
	
	// Gather disciplines
	foreach (Spawn in BlockSpawns) {
		if (Spawn.Tag != C_LobbyName) {
			G_Disciplines[Spawn.Tag] = Spawn.Order;
		}
	}
	
	// Gather goals
	foreach (Name => Type in G_Disciplines) {
		// Gather ports
		foreach (Pole in BlockPoles) {
			if (GetDisciplineName(Pole) == Name) {
				switch (GetGoalType(Pole)) {
					case "Port": {
						G_DisciplinePorts[Pole.Id] = Name;
					}
					case "Goal": {
						G_DisciplineGoals[Pole.Id] = Name;
					}
				}
			}
		}
		
		// Gather specific goals
		switch (Type) {
			case 4: {
				// Rounds
				foreach (Pole in BlockPoles) {
					if (GetDisciplineName(Pole) == Name && GetGoalType(Pole) == "Goal") {
						if (!G_DisciplineCPCount.existskey(Name)) {
							G_DisciplineCPCount[Name] = 0;
						}
						G_DisciplineCPCount[Name] += 1;
					}
				}
			}
		}
	}
}

// Initializes records
Void InitPlayerScore(CSmScore _Score, Boolean _Forced) {
	if (_Score != Null) {
		declare RealNewPlayer for _Score = True;
		if (RealNewPlayer || _Forced) {
			declare Real[Text] DisciplineRecords for _Score;
			DisciplineRecords = Real[Text];
			
			RealNewPlayer = False;
		}
	}
}

Void InitAllPlayersScores(Boolean _Forced) {
	if (_Forced) {
		G_DisciplineRecords.clear();
	}
	foreach (Score in Scores) {
		InitPlayerScore(Score, _Forced);
	}
}

// Get spawn of discipline
CSmBlockSpawn GetDisciplineSpawn(Text _Discipline) {
	declare SpawnName = _Discipline;
	if (SpawnName == "") {
		SpawnName = "Lobby";
	}
	foreach (Spawn in BlockSpawns) {
		if (Spawn.Tag == SpawnName) {
			return Spawn;
		}
	}
	return Null;
}

// Spawn player depending on discipline
Void MySpawnPlayer(CSmPlayer _Player) {
	declare Discipline for _Player = "";
	
	// Reset discipline values
	switch (Discipline) {
		case "": {
			// Lobby
			Chrono::Destroy(_Player.Id);
		}
		default: {
			switch (G_Disciplines[Discipline]) {
				case 1: {
					// Long jumping
					declare Integer AirTimeBegin for _Player;
					AirTimeBegin = -1;
					Chrono::Destroy(_Player.Id);
				}
				case 3: {
					Chrono::Create(_Player.Id);
				}
				case 4: {
					// Rounds
					declare Ident RoundsStartId for _Player;
					RoundsStartId = NullId;
					declare Ident[] RoundsCPs for _Player;
					RoundsCPs = Ident[];
					declare Integer RoundsCount for _Player;
					RoundsCount = 0;
					Chrono::Create(_Player.Id);
				}
			}
		}
	}
	
	// Spawn player at discipline spawn
	SM::SpawnPlayer(_Player, 0, GetDisciplineSpawn(Discipline));
}

// Updates score of a player depending on his performances in the different disciplines
Void UpdatePlayerScore(CSmScore _Score) {
	if (_Score != Null) {
		declare Points = 0.0;
		declare Real[Text] DisciplineRecords for _Score;
		
		// Loop through disciplines
		foreach (Discipline => Record in DisciplineRecords) {
			declare DisciplinePoints = C_PointsPerDiscipline;
			for (Index, 0, 5) {
				if (G_Disciplines[Discipline] == 1 || G_Disciplines[Discipline] == 1) {
					DisciplinePoints *= (Record/G_DisciplineRecords[Discipline]);
				} else {
					DisciplinePoints *= (G_DisciplineRecords[Discipline]/Record);
				}
			}
			Points += DisciplinePoints;
		}
		
		_Score.Points = MathLib::NearestInteger(Points);
	}
}

Void UpdateAllPlayersScores() {
	foreach (Score in Scores) {
		UpdatePlayerScore(Score);
	}
}

// Evaluate try and announce result
Void EvaluateTry(CSmPlayer _Player, Real _Value, Boolean _TimeValue) {
	if (_Player.Score != Null) {
		declare Real Factor;
		if (_TimeValue) {
			Factor = -1.0;
		} else {
			Factor = 1.0;
		}
		declare Text Discipline for _Player;
		declare Real[Text] DisciplineRecords for _Player.Score;
		if (!DisciplineRecords.existskey(Discipline) || _Value*Factor > DisciplineRecords[Discipline]*Factor) {
			DisciplineRecords[Discipline] = _Value;
			if (!G_DisciplineRecords.existskey(Discipline) || _Value*Factor > G_DisciplineRecords[Discipline]*Factor) {
				G_DisciplineRecords[Discipline] = _Value;
			}
			declare UI <=> UIManager.GetUI(_Player);
			if (UI != Null) {
				UI.SendNotice(	"""New Record: {{{_Value}}}!""", CUIConfig::ENoticeLevel::MatchInfo,
								Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Record, 1);
			}
			UpdateAllPlayersScores();
		} else {
			declare UI <=> UIManager.GetUI(_Player);
			if (UI != Null) {
				UI.SendNotice(	"""Try: {{{_Value}}}""", CUIConfig::ENoticeLevel::PlayerInfo,
								Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::Notice, 0);
			}
		}
	}
}

// Returns utility layer manialink
Text GetUtilityLayerManialink() {
	return """
	<script><!--
		#Include "MathLib" as MathLib
		
		main() {
			declare SpeedLabel <=> (Page.GetFirstChild("SpeedLabel") as CMlLabel);
			
			declare netwrite Net_LobbyReset for UI = -1;
			
			declare LastUIUpdate = 0;
			declare Vec3 LastPosition;
			declare LastPositionTime = -1;
			
			while (True) {
				yield;
				
				// Handle events
				foreach (Event in PendingEvents) {
					switch (Event.Type) {
						case CMlEvent::Type::KeyPress: {
							switch (Event.CharPressed) {
								case "2555904": {
									Net_LobbyReset = Now;
								}
							}
						}
					}
				}
				
				// UI update
				if (LastUIUpdate + 350 < Now) {
					LastUIUpdate = Now;
					
					// Calculate speed
					if (InputPlayer != Null && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
						if (LastPositionTime >= 0) {
							declare Speed = (MathLib::Distance(LastPosition, InputPlayer.Position)/((Now-LastPositionTime)/1000.0))*3.6;
							Speed = MathLib::NearestInteger(Speed*100)/100.0;
							SpeedLabel.Value = "$fff"^Speed^" km/h";
							LastPosition = InputPlayer.Position;
							LastPositionTime = Now;
						} else {
							LastPosition = InputPlayer.Position;
							LastPositionTime = Now;
						}
					} else {
						SpeedLabel.Value = "";
					}
				}
			}
		}
	--></script>
	<frame>
		<label id="SpeedLabel" posn="58 -75" style="TextButtonMedium" halign="right" valign="center"/>
	</frame>""";
}

// Updates utility layer
Void UpdateUtilityLayer(CSmPlayer _Player, CUIConfig _UI) {
	if (_Player != Null && _UI != Null) {
		// Check for lobby reset
		declare LastLobbyReset for _UI = -1;
		declare netread Net_LobbyReset for _UI = -1;
		if (Net_LobbyReset > 0 && LastLobbyReset != Net_LobbyReset) {
			// Reset player to lobby
			LastLobbyReset = Net_LobbyReset;
			declare Text Discipline for _Player;
			Discipline = "";
			UnspawnPlayer(_Player);
		}
	}
}

// Create markers layer
Text GetMarkersLayerManialink() {
	declare Manialink = """
	<script><!--
		#Include "TextLib" as TextLib
		
		declare CMlFrame[Text] G_PortFrames;
		declare CMlFrame[Text] G_GoalFrames;
		
		// Show/hide frame and its subcontrols
		Void ShowFrame(CMlFrame _Frame, Boolean _Show) {
			_Frame.Visible = _Show;
			foreach (SubControl in _Frame.Controls) {
				SubControl.Visible = _Show;
			}
		}
		Void ShowFrames(CMlFrame[Text] _Frames, Boolean _Show) {
			foreach (Frame in _Frames) {
				ShowFrame(Frame, _Show);
			}
		}
		Void ShowFrames(CMlFrame[Text] _Frames, Text _Discipline) {
			foreach (Name => Frame in _Frames) {
				ShowFrame(Frame, (TextLib::SubString(Name, 0, TextLib::Length(_Discipline)) == _Discipline));
			}
		}
		
		main() {
			G_PortFrames =  [""";
	declare Index = 0;
	foreach (PortId => Discipline in G_DisciplinePorts) {
		Manialink ^= """
			"{{{Discipline}}}"	=>	(Page.GetFirstChild("{{{BlockPoles[PortId].Tag}}}") as CMlFrame)""";
		if (Index < G_DisciplinePorts.count-1) {
			Manialink ^= ",";
		}
		Index += 1;
	}
	Manialink ^= """];
			G_GoalFrames	=	[""";
	Index = 0;
	foreach (GoalId => Discipline in G_DisciplineGoals) {
		Manialink ^= """
			"{{{Discipline^Index}}}"	=>	(Page.GetFirstChild("{{{BlockPoles[GoalId].Tag^Index}}}") as CMlFrame)""";
		if (Index < G_DisciplineGoals.count-1) {
			Manialink ^= ",";
		}
		Index += 1;
	}
	Manialink ^= """];			
			declare netread Discipline for UI = "";
			
			declare LastUIUpdate = 0;
			
			while (True) {
				yield;
				
				if (LastUIUpdate + 300 < Now) {
					LastUIUpdate = Now;

					// Port markers
					switch (Discipline) {
						case "": {
							ShowFrames(G_PortFrames, True);
						}
						default: {
							ShowFrames(G_PortFrames, False);
						}
					}
					
					// Disciplines markers
					switch (Discipline) {
						case "": {
							ShowFrames(G_GoalFrames, False);
						}
						default: {
							ShowFrames(G_GoalFrames, Discipline);
						}
					}
				}
			}
		}
	--></script>
	
	<format textsize="1"/>""";
	Index = 0;
	foreach (PortId => Discipline in G_DisciplinePorts) {
		Manialink ^= """
			<frame id="{{{BlockPoles[PortId].Tag}}}" hidden="1">
				<quad sizen="{{{TextLib::Length(BlockPoles[PortId].Tag)*1.5}}} 6" posn="0 0 -1" style="BgsPlayerCard" substyle="BgActivePlayerScore" valign="center" halign="center"/>
				<label text="{{{BlockPoles[PortId].Tag}}}" valign="center" halign="center"/>
			</frame>""";
		if (Index < G_DisciplinePorts.count-1) {
			Manialink ^= ",";
		}
		Index += 1;
	}
	Index = 0;
	foreach (GoalId => Discipline in G_DisciplineGoals) {
		Manialink ^= """
			<frame id="{{{BlockPoles[GoalId].Tag^Index}}}" hidden="1">
				<quad sizen="6 6" posn="0 0 -1" style="BgsPlayerCard" substyle="BgActivePlayerScore" valign="center" halign="center"/>
				<quad sizen="7 7" style="Icons64x64_1" substyle="Finish" valign="center" halign="center"/>
			</frame>""";
		if (Index < G_DisciplineGoals.count-1) {
			Manialink ^= ",";
		}
		Index += 1;
	}
	return Manialink;
}

// Creates hud3dmarkers for the current map
Text GetHud3dMarkers() {
	declare Markers = "";
	
	foreach (GoalId => Discipline in G_DisciplinePorts) {
		Markers ^= """<marker pos="{{{BlockPoles[GoalId].Position[0]}}} {{{BlockPoles[GoalId].Position[1]+5.0}}} {{{BlockPoles[GoalId].Position[2]}}}" manialinkframeid="{{{BlockPoles[GoalId].Tag}}}"/>""";
	}
	
	declare Index = 0;
	foreach (GoalId => Discipline in G_DisciplineGoals) {
		Markers ^= """<marker pos="{{{BlockPoles[GoalId].Position[0]}}} {{{BlockPoles[GoalId].Position[1]+5.0}}} {{{BlockPoles[GoalId].Position[2]}}}" manialinkframeid="{{{BlockPoles[GoalId].Tag^Index}}}"/>""";
		Index += 1;
	}
	return Markers;
}

// Return index of a substring in a given string
Integer GetIndexOfSubString(Text _String, Text _SubString) {
	declare SubIndex = 0;
	for (Index, 0, TextLib::Length(_String)-1) {
		if (TextLib::SubString(_String, Index, 1) == TextLib::SubString(_SubString, SubIndex, 1)) {
			// Strings match - Keep going
			SubIndex += 1;
			if (SubIndex >= TextLib::Length(_SubString)) {
				return Index - TextLib::Length(_SubString) + 1;
			}
		} else {
			// String don't match - Reset
			SubIndex = 0;
		}
	}
	return -1;
}

// Get images for disciplines
Text[Text] GetDisciplinesImages(Integer[Text] _Disciplines) {
	declare Text[Text] Images;
	Images["ScoresTab"] = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/Athletics/Ranking.png";
	
	foreach (Name => Type in _Disciplines) {
		if (GetIndexOfSubString(Name, "Ski") >= 0) {
			Images[Name] = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/Athletics/SkiJumping.png";
		} else if (GetIndexOfSubString(Name, "Skat") >= 0) {
			Images[Name] = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/Athletics/Skating.png";
		} else if (GetIndexOfSubString(Name, "Sprint") >= 0) {
			Images[Name] = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/Athletics/Sprinting.png";
		} else if (GetIndexOfSubString(Name, "Climb") >= 0) {
			Images[Name] = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/Athletics/Climbing.png";
		} else if (GetIndexOfSubString(Name, "Hurd") >= 0) {
			Images[Name] = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/Athletics/Hurdling.png";
		} else {
			Images[Name] = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/Athletics/Ranking.png";
		}
	}
	
	return Images;
}

// Custom tab pane layer
CUILayer CreateTabPaneLayer(Text[Text] TabsImages, Integer TabFramePosnX, Integer TabFramePosnY, Boolean HorizontalLayout) {
	if (TabsImages.count <= 0) {
		log("Error : Tab pane built with no pane inside.");
		return Null;
	}
	
	declare CUILayer TabPaneLayer <=> UIManager.UILayerCreate();
	declare TabLayerId = TabPaneLayer.Id;
	
	// Get the first tab to initialize the layer
	declare Text FirstTabKey;
	foreach (Key => Image in TabsImages) {
		FirstTabKey = Key;
		break;
	}
	
	// The ManiaLink associated to the tabs
	declare MLText = """
		<script><!--
		
		main() {
			declare Text _TabsLib_CurrentTab for UI;
			_TabsLib_CurrentTab = "{{{FirstTabKey}}}";
			declare netread Boolean _TabsLib_UsesTabs for UI;
			// _TabsLib_UsesTabs = True;

			declare netread Text _TabsLib_ForcedTab for UI;
			declare 		Text CurrentForcedTab   = "";
			
			declare netread Text _TabsLib_Blinker for UI;
			declare netread Text _TabsLib_BlinkTab for UI;
			declare netread Boolean _TabsLib_DoBlink for UI;
			declare 		Boolean CurrentDoBlink = False;
			
			declare CMlQuad PreviousSelectingQuad	<=>(Page.GetFirstChild("{{{Tabs::GetQuadID(TabLayerId, FirstTabKey)^"_bgUnselect"}}}") as CMlQuad);
			declare CMlQuad PreviousClickedQuad		<=>(Page.GetFirstChild("{{{Tabs::GetQuadID(TabLayerId, FirstTabKey)}}}") as CMlQuad);
			PreviousSelectingQuad.Hide();
			PreviousClickedQuad.Scale = 1.;
			
			while (True) {
				yield;
				
				if (!PageIsVisible) continue;
				
				declare Text ClickedId = "";
				
				if(CurrentDoBlink != _TabsLib_DoBlink) {
					CurrentDoBlink  = _TabsLib_DoBlink;
					declare Text _TabsLib_CurrentTab for UI;
					if (_TabsLib_BlinkTab != _TabsLib_CurrentTab) {
						declare Blinker <=> (Page.GetFirstChild(_TabsLib_Blinker^"_Blink") as CMlQuad);
						if (Blinker != Null) Blinker.Show();
					}
				}

				// emulate clic on a given tab
				if (CurrentForcedTab != _TabsLib_ForcedTab) {
					CurrentForcedTab = _TabsLib_ForcedTab;
					ClickedId = CurrentForcedTab;
				} else {
					foreach (Event in PendingEvents) {
						if (Event.Type == CMlEvent::Type::MouseClick) {
							declare Id = Event.ControlId;
							switch (Id) {
								""";
							foreach (Key => Image in TabsImages) {
								declare QuadId = Tabs::GetQuadID(TabLayerId, Key);
								MLText = MLText^"""case "{{{QuadId}}}": {
									ClickedId = Id;
									break;
								}
								""";
							}
						MLText = MLText^"""
							}
						}
					}
				}
				
				if (ClickedId != "") {
					switch (ClickedId) {""";
							
						foreach (Key => Image in TabsImages) {
							declare QuadId = Tabs::GetQuadID(TabLayerId, Key);
							MLText = MLText^"""case "{{{QuadId}}}": {
								if (_TabsLib_CurrentTab != "{{{Key}}}") {
									_TabsLib_CurrentTab = "{{{Key}}}";
									declare BgUnselect <=> (Page.GetFirstChild("{{{QuadId^"_bgUnselect"}}}") as CMlQuad);
									
									PreviousSelectingQuad.Show();
									BgUnselect.Hide();
									PreviousSelectingQuad = BgUnselect;
									
									declare Blinker <=> (Page.GetFirstChild("{{{QuadId^"_Blink"}}}") as CMlQuad);
									if (Blinker != Null) Blinker.Hide();
									
									declare ClickedQuad <=> (Page.GetFirstChild("{{{QuadId}}}") as CMlQuad);
									ClickedQuad.Scale = 1.0;
									PreviousClickedQuad.Scale = 0.8;
									PreviousClickedQuad = ClickedQuad;
								}
							}
							""";
						}
						
						MLText = MLText^"""
					}
				}
			}
		}
		--></script>
		<frame posn="{{{TabFramePosnX}}} {{{TabFramePosnY}}}">
		""";
		declare Integer XOffset 	= -155;
		declare Integer YOffset 	= 30;
		declare Integer IconSize 	= 15;
		declare Integer QuadY 		= -43;
		declare Integer QuadXPos 	= XOffset + (YOffset-IconSize);
		declare Real BlinkerMargin 	= 1.5;
		declare Text BorderColor	= "0000";
		declare Real BorderSize		= 0.5;
		
		
		foreach( Key => TabImage in TabsImages)
		{
			declare QuadId = Tabs::GetQuadID(TabLayerId, Key);			
			MLText = MLText^"""
				<quad id="{{{QuadId}}}" halign="center" valign="center" posn="{{{QuadXPos + (IconSize/2.)}}} {{{-QuadY - (IconSize/2.)}}} 1" scale="0.8" sizen="{{{IconSize}}} {{{IconSize}}}" """;
			if (TextLib::SubString(TabImage, 0, 4) == "http") {
				MLText = MLText^""" image="{{{TabImage}}}" """;
				MLText = MLText^"""ScriptEvents="true"/>""";
				MLText = MLText^"""
					<quad id="{{{QuadId^"_Blink"}}}" posn="{{{QuadXPos-BlinkerMargin}}} {{{-QuadY+BlinkerMargin}}} 0"  sizen="{{{IconSize+(2*BlinkerMargin)}}} {{{IconSize+(2*BlinkerMargin)}}}" image="{{{TabImage}}}"  hidden="true" />""";
			} else {
				declare SubstyleIcon = TabImage;
				if (SubstyleIcon == "") {
					SubstyleIcon = "ChallengeAuthor";
				}
				MLText = MLText^""" style="Icons128x128_1" substyle="{{{SubstyleIcon}}}" """;
				MLText = MLText^"""ScriptEvents="true"/>""";
				MLText = MLText^"""
					<quad id="{{{QuadId^"_Blink"}}}" posn="{{{QuadXPos-BlinkerMargin}}} {{{-QuadY+BlinkerMargin}}} 0"  sizen="{{{IconSize+(2*BlinkerMargin)}}} {{{IconSize+(2*BlinkerMargin)}}}" style="Icons128x128_Blink" substyle="{{{SubstyleIcon}}}"  hidden="true" />""";
			}
			
			MLText = MLText^"""
				<quad id="{{{QuadId}}}_bg" posn="{{{QuadXPos}}} {{{-QuadY}}} -2"  sizen="{{{IconSize}}} {{{IconSize}}}" bgcolor="{{{"0007"}}}" />""";
			MLText = MLText^"""
				<quad id="{{{QuadId}}}_bgUnselect" posn="{{{QuadXPos}}} {{{-QuadY}}} -2"  sizen="{{{IconSize}}} {{{IconSize}}}" bgcolor="{{{"000b"}}}" />""";
			
			if (HorizontalLayout) {
				QuadXPos = QuadXPos + IconSize;
			} else {
				QuadY = QuadY + IconSize;
			}
		}
		
		MLText = MLText^"""
		</frame>
	""";
	
	TabPaneLayer.ManialinkPage = MLText;
	return TabPaneLayer;
}

// Creates discipline ratings layer
Text GetDisciplineRankingsLayer() {
	declare Manialink = """
		<script><!--
			Void UpdateFrameTab(CUIConfig _UI, CMlPage _Page, Text _TabKey, CMlFrame _MainFrame) {
				declare netread Boolean _TabsLib_UseTabs for _UI;
				if (!_TabsLib_UseTabs) return;
				
				declare Boolean _TabsLib_ScoresLayerIsVisible 	for _UI;
				declare Boolean _TabsLib_AltLayerIsVisible 		for _UI;
				declare Text 	_TabsLib_CurrentTab 			for _UI;
				declare netread Text _TabsLib_ScoresTableTab 	for _UI;
				
				declare Boolean ShowCurrentTab = _TabsLib_AltLayerIsVisible && (_TabsLib_CurrentTab == _TabKey);
				
				if (_TabKey == _TabsLib_ScoresTableTab) {
					ShowCurrentTab = _TabsLib_ScoresLayerIsVisible || (_TabsLib_AltLayerIsVisible && (_TabsLib_CurrentTab == _TabsLib_ScoresTableTab));
				}
			
				if (ShowCurrentTab) {
					_MainFrame.Show();
				} else {
					_MainFrame.Hide();
				}
			}
			
			main() {
				declare LastUIUpdate = 0;
				
				declare Text _TabsLib_CurrentTab for UI;
				
				declare DisciplineRankingsFrame <=> (Page.GetFirstChild("DisciplineRankingsFrame") as CMlFrame);
				declare Rankings_Title <=> (Page.GetFirstChild("Rankings_Title") as CMlLabel);
				
				while (True) {
					yield;
					
					if (LastUIUpdate + 300 < Now) {
						LastUIUpdate = Now;
						
						switch (_TabsLib_CurrentTab) {
							case "ScoresTab": {
								DisciplineRankingsFrame.Hide();
							}
							default: {
								Rankings_Title.Value = _TabsLib_CurrentTab;
								UpdateFrameTab(UI, Page, _TabsLib_CurrentTab, DisciplineRankingsFrame);
							}
						}
					}
				}
			}
		--></script>
		<frame id="DisciplineRankingsFrame" hidden="1">
			<label id="Rankings_Title"/>
		</frame>""";
	return Manialink;
}
